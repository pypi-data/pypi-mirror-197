{"version":3,"file":"lib_index_js.6e353b15f3ac12b63b8e.js","mappings":";;;;;;;;;;;;;;;;;AAA+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCsF;AAClC;AACO;AACV;AACqB;AACvB;AACR;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAe,EAAE,2DAAS,EAAE,gEAAW,EAAE,8DAAW;AACnE;AACA,gBAAgB,WAAW;AAC3B,mFAAmF,mEAAc;AACjG;AACA;AACA;AACA;AACA,iDAAiD,uEAAoB;AACrE;AACA;AACA;AACA;AACA,iCAAiC,OAAO,sEAAmB,IAAI;AAC/D;AACA;AACA,oCAAoC,oDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mEAAgB,IAAI,oEAAiB;AAC3E,uCAAuC,8EAA2B;AAClE,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qCAAqC,gEAAU;AAC/C;AACA,8BAA8B,mDAAM,GAAG,kBAAkB;AACzD;AACA,wBAAwB,qEAAmB,GAAG,2BAA2B;AACzE,wBAAwB,iEAAe;AACvC;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,oBAAoB,wEAAsB;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kCAAkC,iDAAI,GAAG,UAAU;AACnD;AACA,sCAAsC,aAAa;AACnD;AACA,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC","sources":["webpack://jupyterlab-link-share/./lib/handler.js","webpack://jupyterlab-link-share/./lib/index.js"],"sourcesContent":["import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'jupyterlab_link_share', endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import { Clipboard, Dialog, ICommandPalette, showDialog } from '@jupyterlab/apputils';\nimport { IRetroShell } from '@retrolab/application';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\nimport { Menu, Widget } from '@lumino/widgets';\nimport { requestAPI } from './handler';\n/**\n * The command IDs used by the plugin.\n */\nvar CommandIDs;\n(function (CommandIDs) {\n    CommandIDs.share = 'link-share:share';\n})(CommandIDs || (CommandIDs = {}));\n/**\n * Plugin to share the URL of the running Jupyter Server\n */\nconst plugin = {\n    id: 'jupyterlab-link-share:plugin',\n    autoStart: true,\n    optional: [ICommandPalette, IMainMenu, ITranslator, IRetroShell],\n    activate: async (app, palette, menu, translator, retroShell) => {\n        const { commands } = app;\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        commands.addCommand(CommandIDs.share, {\n            label: trans.__('Share Jupyter Server Link'),\n            execute: async () => {\n                let results;\n                const isRunningUnderJupyterHub = PageConfig.getOption('hubUser') !== '';\n                if (isRunningUnderJupyterHub) {\n                    // We are running on a JupyterHub, so let's just use the token set in PageConfig.\n                    // Any extra servers running on the server will still need to use this token anyway,\n                    // as all traffic (including any to jupyter-server-proxy) needs this token.\n                    results = [{ token: PageConfig.getToken() }];\n                }\n                else {\n                    results = await requestAPI('servers');\n                }\n                const links = results.map(server => {\n                    let url;\n                    if (retroShell) {\n                        // On retrolab, take current URL and set ?token to it\n                        url = new URL(location.href);\n                    }\n                    else {\n                        // On JupyterLab, let PageConfig.getUrl do its magic.\n                        // Handles workspaces, single document mode, etc\n                        url = new URL(URLExt.normalize(`${PageConfig.getUrl({\n                            workspace: PageConfig.defaultWorkspace\n                        })}`));\n                    }\n                    const tokenURL = new URL(url.toString());\n                    if (server.token) {\n                        // add token to URL\n                        tokenURL.searchParams.set('token', server.token);\n                    }\n                    return {\n                        noToken: url.toString(),\n                        withToken: tokenURL.toString()\n                    };\n                });\n                const dialogBody = document.createElement('div');\n                const entries = document.createElement('div');\n                dialogBody.appendChild(entries);\n                links.map(link => {\n                    const p = document.createElement('p');\n                    const text = document.createElement('input');\n                    text.dataset.noToken = link.noToken;\n                    text.dataset.withToken = link.withToken;\n                    text.readOnly = true;\n                    text.value = link.noToken;\n                    text.addEventListener('click', e => {\n                        e.target.select();\n                    });\n                    text.style.width = '100%';\n                    p.appendChild(text);\n                    entries.appendChild(p);\n                });\n                // Warn users of the security implications of using this link\n                // FIXME: There *must* be a better way to create HTML\n                const tokenWarning = document.createElement('div');\n                const warningHeader = document.createElement('h3');\n                warningHeader.innerText = trans.__('Security warning!');\n                tokenWarning.appendChild(warningHeader);\n                const tokenMessages = [];\n                tokenMessages.push('Anyone with this link has full access to your notebook server, including all your files!', 'Please be careful who you share it with.');\n                if (isRunningUnderJupyterHub) {\n                    tokenMessages.push(\n                    // You can restart the server to revoke the token in a JupyterHub\n                    'They will be able to access this server AS YOU.');\n                    tokenMessages.push(\n                    // You can restart the server to revoke the token in a JupyterHub\n                    'To revoke access, go to File -> Hub Control Panel, and restart your server');\n                }\n                else {\n                    tokenMessages.push(\n                    // Elsewhere, you *must* shut down your server - no way to revoke it\n                    'Currently, there is no way to revoke access other than shutting down your server');\n                }\n                const noTokenMessage = document.createElement('div');\n                const noTokenMessages = [];\n                if (isRunningUnderJupyterHub) {\n                    noTokenMessages.push('Only users with `access:servers` permissions for this server will be able to use this link.');\n                }\n                else {\n                    noTokenMessages.push('Only authenticated users will be able to use this link.');\n                }\n                tokenMessages.map(m => {\n                    tokenWarning.appendChild(document.createTextNode(trans.__(m)));\n                    tokenWarning.appendChild(document.createElement('br'));\n                });\n                noTokenMessages.map(m => {\n                    noTokenMessage.appendChild(document.createTextNode(trans.__(m)));\n                    noTokenMessage.appendChild(document.createElement('br'));\n                });\n                const messages = {\n                    noToken: noTokenMessage,\n                    withToken: tokenWarning\n                };\n                const message = document.createElement('div');\n                message.appendChild(messages.noToken);\n                // whether there's any token to be used in URLs\n                // if none, no point in adding a checkbox\n                const hasToken = results.filter(server => server.token !== undefined && server.token !== '').length > 0;\n                let includeTokenCheckbox = undefined;\n                if (hasToken) {\n                    // add checkbox to include token _if_ there's a token to include\n                    includeTokenCheckbox = document.createElement('input');\n                    includeTokenCheckbox.type = 'checkbox';\n                    const tokenLabel = document.createElement('label');\n                    tokenLabel.appendChild(includeTokenCheckbox);\n                    tokenLabel.appendChild(document.createTextNode(trans.__('Include token in URL')));\n                    dialogBody.appendChild(tokenLabel);\n                    // when checkbox changes, toggle URL and message\n                    includeTokenCheckbox.addEventListener('change', e => {\n                        const isChecked = e.target.checked;\n                        const key = isChecked ? 'withToken' : 'noToken';\n                        // add or remove the token to the URL inputs\n                        const inputElements = entries.getElementsByTagName('input');\n                        [...inputElements].map(input => {\n                            input.value = input.dataset[key];\n                        });\n                        // swap out the warning message\n                        message.removeChild(message.children[0]);\n                        message.appendChild(messages[key]);\n                    });\n                }\n                dialogBody.appendChild(message);\n                const result = await showDialog({\n                    title: trans.__('Share Jupyter Server Link'),\n                    body: new Widget({ node: dialogBody }),\n                    buttons: [\n                        Dialog.cancelButton({ label: trans.__('Cancel') }),\n                        Dialog.okButton({\n                            label: trans.__('Copy Link'),\n                            caption: trans.__('Copy the link to the Jupyter Server')\n                        })\n                    ]\n                });\n                if (result.button.accept) {\n                    const key = includeTokenCheckbox && includeTokenCheckbox.checked\n                        ? 'withToken'\n                        : 'noToken';\n                    Clipboard.copyToSystem(links[0][key]);\n                }\n            }\n        });\n        if (palette) {\n            palette.addItem({\n                command: CommandIDs.share,\n                category: trans.__('Server')\n            });\n        }\n        if (menu) {\n            // Create a menu\n            const shareMenu = new Menu({ commands });\n            shareMenu.title.label = trans.__('Share');\n            menu.addMenu(shareMenu, { rank: 10000 });\n            // Add the command to the menu\n            shareMenu.addItem({ command: CommandIDs.share });\n        }\n    }\n};\nconst plugins = [plugin];\nexport default plugins;\n"],"names":[],"sourceRoot":""}