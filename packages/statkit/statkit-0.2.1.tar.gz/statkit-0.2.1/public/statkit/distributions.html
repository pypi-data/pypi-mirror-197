<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>statkit.distributions API documentation</title>
<meta name="description" content="Extension of pomegranate distributions to support pseudo counts and value inflation." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>statkit.distributions</code></h1>
</header>
<section id="section-intro">
<p>Extension of pomegranate distributions to support pseudo counts and value inflation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Extension of pomegranate distributions to support pseudo counts and value inflation.
&#34;&#34;&#34;
from abc import ABC, abstractmethod
from typing import Union

from numpy import (
    array,
    fromiter,
    full_like,
    inf,
    isin,
    isnan,
    log,
    ndarray,
    ones_like,
    zeros,
    zeros_like,
)
from numpy.testing import assert_almost_equal
import pomegranate as pg
from pomegranate.distributions import (
    Distribution,
)
from scipy.special import digamma


class Gaussian(pg.NormalDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Gaussian supporting pseudo_counts.

    $$
    p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
    $$
    &#34;&#34;&#34;

    name = &#34;NormalDistribution&#34;

    def __init__(
        self, mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0, **kwargs
    ):
        r&#34;&#34;&#34;
        Args:
            mu: Mean, \( \mu \), or location of Gaussian.
            sigma: Standard deviation, \( \sigma \), measuring the width/scale of the
                Gaussian.
        &#34;&#34;&#34;
        super().__init__(mu, sigma, **kwargs)
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior mean and variance as if they were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            x2 = sigma**2 + mu**2
            self.summaries = [
                self.pseudo_count,
                mu * self.pseudo_count,
                x2 * self.pseudo_count,
            ]


class LogNormal(pg.LogNormalDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate log-normal distribution supporting pseudo_counts.

    $$
    p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
        \exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
    $$
    &#34;&#34;&#34;

    name = &#34;LogNormalDistribution&#34;

    def __init__(
        self, mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0, **kwargs
    ):
        r&#34;&#34;&#34;
        Args:
            mu: Expected value of variable&#39;s log ( \( \mu \) ).
            sigma: Standard deviation of variable log ( \( \sigma \) ).
        &#34;&#34;&#34;
        super().__init__(mu, sigma, **kwargs)
        self.mu_ = mu
        self.sigma_ = sigma
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior mean and variance as if they were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            x2 = self.sigma_**2 + self.mu_**2
            self.summaries = [
                self.pseudo_count,
                self.mu_ * self.pseudo_count,
                x2 * self.pseudo_count,
            ]


class PinnedLogNormal(LogNormal):
    r&#34;&#34;&#34;Log normal distribution where the standard deviation is held fixed to \( \sigma\).

    Only the parameter \( \mu \) is infered from the data, the parameter \( \sigma \)
    is fixed after distribution initialisation.

    $$
    p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
        \exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
    $$
    &#34;&#34;&#34;

    name = &#34;PinnedLogNormalDistribution&#34;

    def from_summaries(self, inertia: float = 0.0):
        &#34;&#34;&#34;Reset pinned standard deviation.&#34;&#34;&#34;
        super().from_summaries(inertia)
        self.parameters: list = [self.parameters[0], self.sigma_]
        return self


class Bernoulli(pg.BernoulliDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Bernoulli distribution supporting pseudo_counts.

    $$
    p(x) = \pi^x (1-\pi)^{1-x},
    $$

    where \( \pi \) is the mean of the distribution.
    &#34;&#34;&#34;

    name = &#34;BernoulliDistribution&#34;

    def __new__(cls, p: float = 0.5, pseudo_count: float = 0.0, **kwargs):
        &#34;&#34;&#34;Peel off `pseudo_count` argument for pomegranate __cinit__.&#34;&#34;&#34;
        return super().__new__(cls, p, **kwargs)

    def __init__(self, p: float = 0.5, pseudo_count: float = 0.0, **kwargs):
        r&#34;&#34;&#34;
        Args:
            p: Probability \( \pi \) of sampling a one.
        &#34;&#34;&#34;
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior probability `p` as if it were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            self.summaries = [
                self.pseudo_count,
                p * self.pseudo_count,
            ]


class Exponential(pg.ExponentialDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate exponential distribution supporting pseudo_counts.

    $$
    p(x) = \lambda \exp(-\lambda x).
    $$
    &#34;&#34;&#34;

    name = &#34;ExponentialDistribution&#34;

    def __init__(self, rate: float = 1.0, pseudo_count: float = 0.0, **kwargs):
        r&#34;&#34;&#34;
        Args:
            rate: Decay rate \( \lambda \).
        &#34;&#34;&#34;
        super().__init__(rate, **kwargs)
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior probability `p` as if it were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            self.summaries = [
                self.pseudo_count,
                self.pseudo_count / rate,
            ]


class Gamma(pg.GammaDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Gamma distribution supporting pseudo_counts.

    $$
    p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
    $$
    &#34;&#34;&#34;

    name = &#34;GammaDistribution&#34;

    def __init__(
        self, alpha: float = 1.0, beta: float = 1.0, pseudo_count: float = 0.0, **kwargs
    ):
        r&#34;&#34;&#34;
        Args:
            alpha: Shape \( \alpha \) of the distribution.
            beta:  Rate \( \beta \), or inverse scale, of the distribution.
        &#34;&#34;&#34;
        super().__init__(alpha, beta, **kwargs)
        if alpha &lt;= 0.0 or beta &lt;= 0.0:
            raise ValueError(&#34;Shape `alpha` and rate `beta` must be positive definite!&#34;)

        self.pseudo_count = pseudo_count

        if self.pseudo_count &gt; 0:
            self.summaries = [
                # sum_i x_i * w_i,
                alpha / beta * self.pseudo_count,
                # sum_i log(x_i) * w_i, E[ln(X)] = ψ(α) − ln(β).
                self.pseudo_count * (digamma(alpha) - log(beta)),
                # sum_i w_i.
                self.pseudo_count,
            ]


class Discrete(pg.DiscreteDistribution):
    &#34;&#34;&#34;Extension of Pomegranate discrete distribution supporting pseudo_counts.&#34;&#34;&#34;

    name = &#34;DiscreteDistribution&#34;

    def __new__(cls, characters: dict, pseudo_count: float = 0.0, **kwargs):
        &#34;&#34;&#34;Peel off `pseudo_count` argument for pomegranate __cinit__.&#34;&#34;&#34;
        return super().__new__(cls, characters, **kwargs)

    def __init__(self, characters: dict, pseudo_count: float = 0.0, **kwargs):
        self.pseudo_count = pseudo_count

        if self.pseudo_count &gt; 0:
            self.summaries: list = [
                {
                    # p(x=key) * n where `n` is the pseudo count.
                    key: characters[key] * self.pseudo_count
                    for key in self.summaries[0].keys()
                },
                self.pseudo_count,
            ]

    def log_probability(self, X):
        &#34;&#34;&#34;Vectorised implementation of DiscreteDistribution log prob.&#34;&#34;&#34;
        if isinstance(X, ndarray):
            if len(X) == 1:
                return super().log_probability(float(X))

            logp_iter = map(super().log_probability, X)
            return fromiter(logp_iter, dtype=float)

        return super().log_probability(X)


class Poisson(pg.PoissonDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Poisson supporting pseudo_counts.

    $$
    p(x) = \frac{x^l e^{-l}}{x!}
    $$
    &#34;&#34;&#34;

    name = &#34;PoissonDistribution&#34;

    def __init__(self, l: float = 1.0, pseudo_count: float = 0.0, **kwargs):
        &#34;&#34;&#34;
        Args:
            l: Rate (and therefore, the mean) of the distribution.
        &#34;&#34;&#34;
        super().__init__(l, **kwargs)
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior mean and variance as if they were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            self.summaries = [
                # Nota bene: Here the order of the summaries is swapped compared to
                # other distributions.
                l * self.pseudo_count,
                self.pseudo_count,
            ]


class _AbstractInflated(ABC, Distribution):
    r&#34;&#34;&#34;
    Probability density where some values \( \{x_1,..,x_n\} \) have finite probability.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_{x^\prime} \delta(x-x^\prime) &amp; x^\prime \in \{x_1,\dots, x_n\}, \\
            \left(1 - \sum_{x^\prime} \pi_{x^\prime} \right) p_c(x)  &amp; x \notin \{x_1, \dots ,x_n\},
        \end{matrix}
        \right.
    $$
    where \(\pi_x \) is a categorical distribution and \( p_c(x) \) is the
    complementary distribution.
    &#34;&#34;&#34;

    @property
    @abstractmethod
    def ComplementaryDistribution(self):
        &#34;&#34;&#34;Distribution class for modelling x!=0 values.&#34;&#34;&#34;

    @property
    def parameters(self) -&gt; list:
        return self.pi_.parameters + self.p_complement_.parameters

    @parameters.setter
    def parameters(self, parameters: list):
        self.pi_.parameters = [parameters[0]]
        self.p_complement_.parameters = parameters[1:]

    def from_summaries(self, inertia: float = 0.0):
        &#34;&#34;&#34;Compute sufficient statistics from summaries.&#34;&#34;&#34;
        self.pi_.from_summaries(inertia)
        self.p_complement_.from_summaries(inertia)

    def fit(self, *args, **kwargs):
        &#34;&#34;&#34;Add sklearn compatible `self` return to pomegranate implementation.&#34;&#34;&#34;
        super().fit(*args, **kwargs)

        return self

    @classmethod
    def blank(cls):
        return cls()


class _BaseInflated(_AbstractInflated):
    r&#34;&#34;&#34;Probability density where some values \( \{x_1,\dots ,x_n\} \) have finite probability.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_{x^\prime} \delta(x-x^\prime) &amp; x^\prime \in \{x_1,\dots, x_n\}, \\
            \left(1 - \sum_{x^\prime} \pi_{x^\prime} \right) p_c(x)  &amp; x \notin \{x_1, \dots ,x_n\},
        \end{matrix}
        \right.
    $$
    where `pi` is a categorical distribution and \( p_c(x) \) is the complementary
    distribution.&#34;&#34;&#34;

    name = &#34;InflatedDistribution&#34;

    def __init__(
        self,
        special_values: Union[tuple, dict],
        *complement_args,
        pseudo_count: float = 0.0
    ):
        &#34;&#34;&#34;
        Args:
            special_values: Values to inflate (tuple), or the values (=key) and
                corresponding probabilities (=value) when a dict.
            *complement_args: Arguments to pass to the original distribution (the
                probability density).
        &#34;&#34;&#34;
        self.pseudo_count = pseudo_count

        if isinstance(special_values, dict):
            assert &#34;complement&#34; in special_values, &#34;Missing complement key!&#34;
            # Check that the probabilities are normalised.
            assert_almost_equal(sum(special_values.values()), 1)

            # Elements to inflate.
            self.inflated_keys = tuple(
                key for key in special_values.keys() if key != &#34;complement&#34;
            )
            p_keys = special_values

        else:
            # Elements to inflate.
            self.inflated_keys = tuple(
                key for key in special_values if key != &#34;complement&#34;
            )

            # No probabilities provided, equal a priori probability.
            p_flat = 1 / (len(self.inflated_keys) + 1)

            # Initialise probability of non-inflated element.
            p_keys = {&#34;complement&#34;: p_flat}

            # Initialise probability of inflated elements.
            p_keys.update({character: p_flat for character in special_values})

        self.pi_ = Discrete(p_keys, pseudo_count=self.pseudo_count)
        self.p_complement_ = self.ComplementaryDistribution(
            *complement_args, pseudo_count=pseudo_count
        )

    def __reduce__(self) -&gt; tuple:
        &#34;&#34;&#34;Serialize distribution for pickling.&#34;&#34;&#34;
        return self.__class__, tuple(self.parameters)

    def summarize(self, X, weights=None, column_index: int = 0):
        &#34;&#34;&#34;Reduce samples to summary statistics.&#34;&#34;&#34;
        # First summarize Bernoulli distribution.
        if len(X.shape) &gt; 1:
            x_i = X[:, column_index]
        else:
            x_i = X

        if weights is None:
            weights = ones_like(x_i)

        x_pi = x_i.copy().astype(object)
        is_inflated_x = isin(x_i, test_elements=self.inflated_keys)
        is_complement = (~isnan(x_i)) &amp; (~is_inflated_x)
        x_pi[is_inflated_x] = x_i[is_inflated_x]
        x_pi[is_complement] = &#34;complement&#34;

        self.pi_.summarize(x_pi, weights)
        self.p_complement_.summarize(x_i[is_complement], weights[is_complement])

    def log_probability(self, X):
        &#34;&#34;&#34;Log probability of zero inflated distribution.&#34;&#34;&#34;
        if not isinstance(X, ndarray):
            X = array(X, dtype=float)
        elif X.dtype != float:
            X = X.astype(float)

        # NaN have probability= 1 -&gt; log[probability] = 0.
        log_p = zeros_like(X, dtype=float)

        # p(x=0) = pi.
        is_inflated_x = isin(X, test_elements=self.inflated_keys)
        # Categorical distribution doesn&#39;t support direct element-wise
        # operation, so use map instead..
        log_p[is_inflated_x] = fromiter(
            map(self.pi_.log_probability, X[is_inflated_x]), dtype=float
        )

        is_complement = (~isnan(X)) &amp; (~is_inflated_x)
        log_pi_compl = full_like(
            X[is_complement], self.pi_.log_probability(&#34;complement&#34;)
        )
        log_p_complement = self.p_complement_.log_probability(X[is_complement])
        log_p[is_complement] = log_pi_compl + log_p_complement

        return log_p

    def sample(self, size: int = 1):
        &#34;&#34;&#34;Generate random variate from distribution.&#34;&#34;&#34;
        x_samples = self.pi_.sample(size).astype(object)
        is_complement = x_samples == &#34;complement&#34;
        # Convert &#39;text&#39; samples back to floats.
        x_samples[~is_complement] = x_samples[~is_complement].astype(float)
        n_complement = is_complement.sum()
        x_samples[is_complement] = self.p_complement_.sample(n_complement)
        return x_samples.astype(float)


class _BaseZeroInflated(_AbstractInflated):
    &#34;&#34;&#34;Zero-inflated flated density where p(x=0) has finite probability.

    That is,
        p(x) = { pi             x=0,
               { (1-pi) p_c(x)  x =/= 0,
    where `pi` is a Bernoulli distribution and p_c(x) is the complementary
    distribution.
    &#34;&#34;&#34;

    name = &#34;ZeroInflatedDistribution&#34;

    def __init__(self, pi: float = 0.5, *complement_args, pseudo_count: float = 0.0):
        self.pseudo_count = pseudo_count
        self.pi = pi
        self.complement_args = complement_args
        self.pi_ = Bernoulli(self.pi, pseudo_count=self.pseudo_count)
        self.p_complement_ = self.ComplementaryDistribution(
            *self.complement_args, pseudo_count=self.pseudo_count
        )

    def fit(self, X, y=None):
        &#34;&#34;&#34;Initialise models and fit distributions.&#34;&#34;&#34;
        super().fit(X, y)
        return self

    def sample(self, size: int = 1):
        &#34;&#34;&#34;Generate random variate from distribution.&#34;&#34;&#34;
        x_samples = zeros(size)
        # Zeros are correspond to 1 in self.pi.
        non_zero = self.pi_.sample(size) == 0
        n_non_zero = non_zero.sum()
        x_samples[non_zero] = self.p_complement_.sample(n_non_zero)
        return x_samples

    def log_probability(self, X):
        &#34;&#34;&#34;Log probability of zero inflated distribution.&#34;&#34;&#34;
        if not isinstance(X, ndarray):
            X = array(X, dtype=float)
        elif X.dtype != float:
            X = X.astype(float)

        # NaN have probability= 1 -&gt; log[probability] = 0.
        log_p = zeros_like(X, dtype=float)

        # p(x=0) = pi.
        is_zero = X == 0.0
        log_p[is_zero] = self.pi_.log_probability(ones_like(X[is_zero]))

        is_non_zero = (~isnan(X)) &amp; (~is_zero)
        log_one_min_pi = self.pi_.log_probability(zeros_like(X[is_non_zero]))
        log_p_complement = self.p_complement_.log_probability(X[is_non_zero])
        log_p[is_non_zero] = log_one_min_pi + log_p_complement

        return log_p

    def summarize(self, X, weights=None, column_index: int = 0):
        &#34;&#34;&#34;Reduce samples to summary statistics.&#34;&#34;&#34;
        # First summarize Bernoulli distribution.
        if len(X.shape) &gt; 1:
            x_i = X[:, column_index]
        else:
            x_i = X

        if weights is None:
            weights = ones_like(x_i)

        x_pi = x_i.copy()
        is_zero = x_i == 0.0
        is_non_zero = (~isnan(x_i)) &amp; (~is_zero)
        x_pi[is_zero] = 1
        x_pi[is_non_zero] = 0

        self.pi_.summarize(x_pi, weights)
        self.p_complement_.summarize(x_i[is_non_zero], weights[is_non_zero])


class ZeroInflatedGaussian(_BaseZeroInflated):
    r&#34;&#34;&#34;Model p(x=0) with finite probability, and the remainder as Gaussian.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_0 \delta(x) &amp; x = 0, \\
            \left(1 - \pi_0 \right) \frac{1}{\sqrt{2\pi \sigma^2} e^{-\frac{(x-\mu)^2}{2\sigma^2}}  &amp; x \neq 0.
        \end{matrix}
        \right.
    $$

    The mean of this distribution is:
    $$
    (1-\pi_0) \mu.
    $$
    &#34;&#34;&#34;

    ComplementaryDistribution = Gaussian
    name = &#34;ZeroInflatedGaussian&#34;

    def __init__(
        self,
        pi: float = 0.5,
        mu: float = 0.0,
        sigma: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        r&#34;&#34;&#34;
        Args:
            pi: Probability \( \pi \) of observering a zero.
            mu: Mean \( \mu \) of Gaussian.
            sigma: Standard deviation \( \sigma \) of Gaussian.
        &#34;&#34;&#34;
        super().__init__(pi, mu, sigma, pseudo_count=pseudo_count)


class InflatedGaussian(_BaseInflated):
    &#34;&#34;&#34;Gaussian with finite probability of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = Gaussian
    name = &#34;InflatedGaussian&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        mu: float = 0.0,
        sigma: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, mu, sigma, pseudo_count=pseudo_count)


class InflatedLogNormal(_BaseInflated):
    r&#34;&#34;&#34;Log normal with finite probability of observing `special_values`.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_{x^\prime} \delta(x-x^\prime) &amp; x^\prime \in \{x_1,\dots, x_n\}, \\
            \left(1 - \sum_{x^\prime} \pi_{x^\prime} \right) \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
        \exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right)  &amp; x \notin \{x_1, \dots ,x_n\},
        \end{matrix}
        \right.
    $$
    where \(\pi_x \) is a categorical distribution.
    &#34;&#34;&#34;

    ComplementaryDistribution = LogNormal
    name = &#34;InflatedLogNormal&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        mu: float = 0.0,
        sigma: float = 1,
        pseudo_count: float = 0.0,
    ):
        r&#34;&#34;&#34;
        Args:
            special_values: Set of values \( \{x_1,\dots, x_n\} \) with finite
                probability.
            mu: Expected value of variable&#39;s log ( \( \mu \) ).
            sigma: Standard deviation of variable log ( \( \sigma \) ).
        &#34;&#34;&#34;
        super().__init__(special_values, mu, sigma, pseudo_count=pseudo_count)


class InflatedPinnedLogNormal(_BaseInflated):
    &#34;&#34;&#34;Log normal with finite probability of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = PinnedLogNormal
    name = &#34;InflatedPinnedLogNormal&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        mu: float = 0.0,
        sigma: float = 1,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, mu, sigma, pseudo_count=pseudo_count)


class InflatedGamma(_BaseInflated):
    &#34;&#34;&#34;Gamma distribution with finite prob. of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = Gamma
    name = &#34;InflatedGamma&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        alpha: float = 1.0,
        beta: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, alpha, beta, pseudo_count=pseudo_count)


class InflatedExponential(_BaseInflated):
    &#34;&#34;&#34;Exponential distribution with finite prob. of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = Exponential
    name = &#34;InflatedExponential&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        rate: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, rate, pseudo_count=pseudo_count)


class ZeroInflatedExponential(_BaseZeroInflated):
    r&#34;&#34;&#34;Exponential distribution with finite probability of value zero.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_0 \delta(x) &amp; x = 0, \\
            \left(1 - \pi_0 \right) \lambda  e^{-\lambda x}  &amp; x \neq 0.
        \end{matrix}
        \right.
    $$
    &#34;&#34;&#34;

    ComplementaryDistribution = Exponential
    name = &#34;ZeroInflatedExponential&#34;

    def __init__(
        self,
        pi: float = 0.5,
        rate: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        r&#34;&#34;&#34;Initialise distribution with default values.

        Args:
            pi: Probability of observing the value zero ( \( \pi_0 \) ).
            rate: Inverse length scale \( \lambda \).
            pseudo_count: Act like `pi` and `rate` were obtained from this many
                observations.
        &#34;&#34;&#34;
        super().__init__(pi, rate, pseudo_count=pseudo_count)


class ZeroInflatedGamma(_BaseZeroInflated):
    r&#34;&#34;&#34;Gamma distribution with finite probability of observering zero.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_0 \delta(x) &amp; x = 0, \\
            \left(1 - \pi_0 \right)
            \frac{\beta^{\alpha}}{\Gamma(\alpha)} x^{\alpha-1} e^{-\beta x} &amp; x \neq 0.
        \end{matrix}
        \right.
    $$
    &#34;&#34;&#34;

    ComplementaryDistribution = Gamma
    name = &#34;ZeroInflatedGamma&#34;

    def __init__(
        self,
        pi: float = 0.5,
        alpha: float = 1.0,
        beta: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(pi, alpha, beta, pseudo_count=pseudo_count)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="statkit.distributions.Bernoulli"><code class="flex name class">
<span>class <span class="ident">Bernoulli</span></span>
<span>(</span><span>p: float = 0.5, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Bernoulli distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \pi^x (1-\pi)^{1-x},
</span><script type="math/tex; mode=display">
p(x) = \pi^x (1-\pi)^{1-x},
</script></span></p>
<p>where <span><span class="MathJax_Preview"> \pi </span><script type="math/tex"> \pi </script></span> is the mean of the distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p</code></strong></dt>
<dd>Probability <span><span class="MathJax_Preview"> \pi </span><script type="math/tex"> \pi </script></span> of sampling a one.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bernoulli(pg.BernoulliDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Bernoulli distribution supporting pseudo_counts.

    $$
    p(x) = \pi^x (1-\pi)^{1-x},
    $$

    where \( \pi \) is the mean of the distribution.
    &#34;&#34;&#34;

    name = &#34;BernoulliDistribution&#34;

    def __new__(cls, p: float = 0.5, pseudo_count: float = 0.0, **kwargs):
        &#34;&#34;&#34;Peel off `pseudo_count` argument for pomegranate __cinit__.&#34;&#34;&#34;
        return super().__new__(cls, p, **kwargs)

    def __init__(self, p: float = 0.5, pseudo_count: float = 0.0, **kwargs):
        r&#34;&#34;&#34;
        Args:
            p: Probability \( \pi \) of sampling a one.
        &#34;&#34;&#34;
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior probability `p` as if it were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            self.summaries = [
                self.pseudo_count,
                p * self.pseudo_count,
            ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pomegranate.distributions.BernoulliDistribution.BernoulliDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.Bernoulli.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.Discrete"><code class="flex name class">
<span>class <span class="ident">Discrete</span></span>
<span>(</span><span>characters: dict, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate discrete distribution supporting pseudo_counts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Discrete(pg.DiscreteDistribution):
    &#34;&#34;&#34;Extension of Pomegranate discrete distribution supporting pseudo_counts.&#34;&#34;&#34;

    name = &#34;DiscreteDistribution&#34;

    def __new__(cls, characters: dict, pseudo_count: float = 0.0, **kwargs):
        &#34;&#34;&#34;Peel off `pseudo_count` argument for pomegranate __cinit__.&#34;&#34;&#34;
        return super().__new__(cls, characters, **kwargs)

    def __init__(self, characters: dict, pseudo_count: float = 0.0, **kwargs):
        self.pseudo_count = pseudo_count

        if self.pseudo_count &gt; 0:
            self.summaries: list = [
                {
                    # p(x=key) * n where `n` is the pseudo count.
                    key: characters[key] * self.pseudo_count
                    for key in self.summaries[0].keys()
                },
                self.pseudo_count,
            ]

    def log_probability(self, X):
        &#34;&#34;&#34;Vectorised implementation of DiscreteDistribution log prob.&#34;&#34;&#34;
        if isinstance(X, ndarray):
            if len(X) == 1:
                return super().log_probability(float(X))

            logp_iter = map(super().log_probability, X)
            return fromiter(logp_iter, dtype=float)

        return super().log_probability(X)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pomegranate.distributions.DiscreteDistribution.DiscreteDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.Discrete.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="statkit.distributions.Discrete.log_probability"><code class="name flex">
<span>def <span class="ident">log_probability</span></span>(<span>self, X)</span>
</code></dt>
<dd>
<div class="desc"><p>Vectorised implementation of DiscreteDistribution log prob.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_probability(self, X):
    &#34;&#34;&#34;Vectorised implementation of DiscreteDistribution log prob.&#34;&#34;&#34;
    if isinstance(X, ndarray):
        if len(X) == 1:
            return super().log_probability(float(X))

        logp_iter = map(super().log_probability, X)
        return fromiter(logp_iter, dtype=float)

    return super().log_probability(X)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.Exponential"><code class="flex name class">
<span>class <span class="ident">Exponential</span></span>
<span>(</span><span>rate: float = 1.0, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate exponential distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \lambda \exp(-\lambda x).
</span><script type="math/tex; mode=display">
p(x) = \lambda \exp(-\lambda x).
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rate</code></strong></dt>
<dd>Decay rate <span><span class="MathJax_Preview"> \lambda </span><script type="math/tex"> \lambda </script></span>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Exponential(pg.ExponentialDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate exponential distribution supporting pseudo_counts.

    $$
    p(x) = \lambda \exp(-\lambda x).
    $$
    &#34;&#34;&#34;

    name = &#34;ExponentialDistribution&#34;

    def __init__(self, rate: float = 1.0, pseudo_count: float = 0.0, **kwargs):
        r&#34;&#34;&#34;
        Args:
            rate: Decay rate \( \lambda \).
        &#34;&#34;&#34;
        super().__init__(rate, **kwargs)
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior probability `p` as if it were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            self.summaries = [
                self.pseudo_count,
                self.pseudo_count / rate,
            ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pomegranate.distributions.ExponentialDistribution.ExponentialDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.Exponential.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.Gamma"><code class="flex name class">
<span>class <span class="ident">Gamma</span></span>
<span>(</span><span>alpha: float = 1.0, beta: float = 1.0, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Gamma distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
</span><script type="math/tex; mode=display">
p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alpha</code></strong></dt>
<dd>Shape <span><span class="MathJax_Preview"> \alpha </span><script type="math/tex"> \alpha </script></span> of the distribution.</dd>
<dt><strong><code>beta</code></strong></dt>
<dd>Rate <span><span class="MathJax_Preview"> \beta </span><script type="math/tex"> \beta </script></span>, or inverse scale, of the distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gamma(pg.GammaDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Gamma distribution supporting pseudo_counts.

    $$
    p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
    $$
    &#34;&#34;&#34;

    name = &#34;GammaDistribution&#34;

    def __init__(
        self, alpha: float = 1.0, beta: float = 1.0, pseudo_count: float = 0.0, **kwargs
    ):
        r&#34;&#34;&#34;
        Args:
            alpha: Shape \( \alpha \) of the distribution.
            beta:  Rate \( \beta \), or inverse scale, of the distribution.
        &#34;&#34;&#34;
        super().__init__(alpha, beta, **kwargs)
        if alpha &lt;= 0.0 or beta &lt;= 0.0:
            raise ValueError(&#34;Shape `alpha` and rate `beta` must be positive definite!&#34;)

        self.pseudo_count = pseudo_count

        if self.pseudo_count &gt; 0:
            self.summaries = [
                # sum_i x_i * w_i,
                alpha / beta * self.pseudo_count,
                # sum_i log(x_i) * w_i, E[ln(X)] = ψ(α) − ln(β).
                self.pseudo_count * (digamma(alpha) - log(beta)),
                # sum_i w_i.
                self.pseudo_count,
            ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pomegranate.distributions.GammaDistribution.GammaDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.Gamma.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.Gaussian"><code class="flex name class">
<span>class <span class="ident">Gaussian</span></span>
<span>(</span><span>mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Gaussian supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
</span><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mu</code></strong></dt>
<dd>Mean, <span><span class="MathJax_Preview"> \mu </span><script type="math/tex"> \mu </script></span>, or location of Gaussian.</dd>
<dt><strong><code>sigma</code></strong></dt>
<dd>Standard deviation, <span><span class="MathJax_Preview"> \sigma </span><script type="math/tex"> \sigma </script></span>, measuring the width/scale of the
Gaussian.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gaussian(pg.NormalDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Gaussian supporting pseudo_counts.

    $$
    p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
    $$
    &#34;&#34;&#34;

    name = &#34;NormalDistribution&#34;

    def __init__(
        self, mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0, **kwargs
    ):
        r&#34;&#34;&#34;
        Args:
            mu: Mean, \( \mu \), or location of Gaussian.
            sigma: Standard deviation, \( \sigma \), measuring the width/scale of the
                Gaussian.
        &#34;&#34;&#34;
        super().__init__(mu, sigma, **kwargs)
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior mean and variance as if they were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            x2 = sigma**2 + mu**2
            self.summaries = [
                self.pseudo_count,
                mu * self.pseudo_count,
                x2 * self.pseudo_count,
            ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pomegranate.distributions.NormalDistribution.NormalDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.Gaussian.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.InflatedExponential"><code class="flex name class">
<span>class <span class="ident">InflatedExponential</span></span>
<span>(</span><span>special_values: Union[dict, tuple] = (0, 1, inf), rate: float = 1.0, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Exponential distribution with finite prob. of observing <code>special_values</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>special_values</code></strong></dt>
<dd>Values to inflate (tuple), or the values (=key) and
corresponding probabilities (=value) when a dict.</dd>
<dt><strong><code>*complement_args</code></strong></dt>
<dd>Arguments to pass to the original distribution (the
probability density).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InflatedExponential(_BaseInflated):
    &#34;&#34;&#34;Exponential distribution with finite prob. of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = Exponential
    name = &#34;InflatedExponential&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        rate: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, rate, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.InflatedExponential.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate exponential distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \lambda \exp(-\lambda x).
</span><script type="math/tex; mode=display">
p(x) = \lambda \exp(-\lambda x).
</script></span></p></div>
</dd>
<dt id="statkit.distributions.InflatedExponential.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.InflatedGamma"><code class="flex name class">
<span>class <span class="ident">InflatedGamma</span></span>
<span>(</span><span>special_values: Union[dict, tuple] = (0, 1, inf), alpha: float = 1.0, beta: float = 1.0, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Gamma distribution with finite prob. of observing <code>special_values</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>special_values</code></strong></dt>
<dd>Values to inflate (tuple), or the values (=key) and
corresponding probabilities (=value) when a dict.</dd>
<dt><strong><code>*complement_args</code></strong></dt>
<dd>Arguments to pass to the original distribution (the
probability density).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InflatedGamma(_BaseInflated):
    &#34;&#34;&#34;Gamma distribution with finite prob. of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = Gamma
    name = &#34;InflatedGamma&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        alpha: float = 1.0,
        beta: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, alpha, beta, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.InflatedGamma.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Gamma distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
</span><script type="math/tex; mode=display">
p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
</script></span></p></div>
</dd>
<dt id="statkit.distributions.InflatedGamma.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.InflatedGaussian"><code class="flex name class">
<span>class <span class="ident">InflatedGaussian</span></span>
<span>(</span><span>special_values: Union[dict, tuple] = (0, 1, inf), mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Gaussian with finite probability of observing <code>special_values</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>special_values</code></strong></dt>
<dd>Values to inflate (tuple), or the values (=key) and
corresponding probabilities (=value) when a dict.</dd>
<dt><strong><code>*complement_args</code></strong></dt>
<dd>Arguments to pass to the original distribution (the
probability density).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InflatedGaussian(_BaseInflated):
    &#34;&#34;&#34;Gaussian with finite probability of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = Gaussian
    name = &#34;InflatedGaussian&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        mu: float = 0.0,
        sigma: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, mu, sigma, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.InflatedGaussian.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Gaussian supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
</span><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
</script></span></p></div>
</dd>
<dt id="statkit.distributions.InflatedGaussian.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.InflatedLogNormal"><code class="flex name class">
<span>class <span class="ident">InflatedLogNormal</span></span>
<span>(</span><span>special_values: Union[dict, tuple] = (0, 1, inf), mu: float = 0.0, sigma: float = 1, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Log normal with finite probability of observing <code>special_values</code>.</p>
<p>That is,
<span><span class="MathJax_Preview">
p(x) = \left \{ \begin{matrix}
\pi_{x^\prime} \delta(x-x^\prime) &amp; x^\prime \in \{x_1,\dots, x_n\}, \\
\left(1 - \sum_{x^\prime} \pi_{x^\prime} \right) \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right)
&amp; x \notin \{x_1, \dots ,x_n\},
\end{matrix}
\right.
</span><script type="math/tex; mode=display">
p(x) = \left \{ \begin{matrix}
\pi_{x^\prime} \delta(x-x^\prime) & x^\prime \in \{x_1,\dots, x_n\}, \\
\left(1 - \sum_{x^\prime} \pi_{x^\prime} \right) \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right)
& x \notin \{x_1, \dots ,x_n\},
\end{matrix}
\right.
</script></span>
where <span><span class="MathJax_Preview">\pi_x </span><script type="math/tex">\pi_x </script></span> is a categorical distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>special_values</code></strong></dt>
<dd>Set of values <span><span class="MathJax_Preview"> \{x_1,\dots, x_n\} </span><script type="math/tex"> \{x_1,\dots, x_n\} </script></span> with finite
probability.</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>Expected value of variable's log ( <span><span class="MathJax_Preview"> \mu </span><script type="math/tex"> \mu </script></span> ).</dd>
<dt><strong><code>sigma</code></strong></dt>
<dd>Standard deviation of variable log ( <span><span class="MathJax_Preview"> \sigma </span><script type="math/tex"> \sigma </script></span> ).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InflatedLogNormal(_BaseInflated):
    r&#34;&#34;&#34;Log normal with finite probability of observing `special_values`.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_{x^\prime} \delta(x-x^\prime) &amp; x^\prime \in \{x_1,\dots, x_n\}, \\
            \left(1 - \sum_{x^\prime} \pi_{x^\prime} \right) \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
        \exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right)  &amp; x \notin \{x_1, \dots ,x_n\},
        \end{matrix}
        \right.
    $$
    where \(\pi_x \) is a categorical distribution.
    &#34;&#34;&#34;

    ComplementaryDistribution = LogNormal
    name = &#34;InflatedLogNormal&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        mu: float = 0.0,
        sigma: float = 1,
        pseudo_count: float = 0.0,
    ):
        r&#34;&#34;&#34;
        Args:
            special_values: Set of values \( \{x_1,\dots, x_n\} \) with finite
                probability.
            mu: Expected value of variable&#39;s log ( \( \mu \) ).
            sigma: Standard deviation of variable log ( \( \sigma \) ).
        &#34;&#34;&#34;
        super().__init__(special_values, mu, sigma, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.InflatedLogNormal.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate log-normal distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</span><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</script></span></p></div>
</dd>
<dt id="statkit.distributions.InflatedLogNormal.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.InflatedPinnedLogNormal"><code class="flex name class">
<span>class <span class="ident">InflatedPinnedLogNormal</span></span>
<span>(</span><span>special_values: Union[dict, tuple] = (0, 1, inf), mu: float = 0.0, sigma: float = 1, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Log normal with finite probability of observing <code>special_values</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>special_values</code></strong></dt>
<dd>Values to inflate (tuple), or the values (=key) and
corresponding probabilities (=value) when a dict.</dd>
<dt><strong><code>*complement_args</code></strong></dt>
<dd>Arguments to pass to the original distribution (the
probability density).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InflatedPinnedLogNormal(_BaseInflated):
    &#34;&#34;&#34;Log normal with finite probability of observing `special_values`.&#34;&#34;&#34;

    ComplementaryDistribution = PinnedLogNormal
    name = &#34;InflatedPinnedLogNormal&#34;

    def __init__(
        self,
        special_values: Union[dict, tuple] = (0, 1, inf),
        mu: float = 0.0,
        sigma: float = 1,
        pseudo_count: float = 0.0,
    ):
        super().__init__(special_values, mu, sigma, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.InflatedPinnedLogNormal.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Log normal distribution where the standard deviation is held fixed to <span><span class="MathJax_Preview"> \sigma</span><script type="math/tex"> \sigma</script></span>.</p>
<p>Only the parameter <span><span class="MathJax_Preview"> \mu </span><script type="math/tex"> \mu </script></span> is infered from the data, the parameter <span><span class="MathJax_Preview"> \sigma </span><script type="math/tex"> \sigma </script></span>
is fixed after distribution initialisation.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</span><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</script></span></p></div>
</dd>
<dt id="statkit.distributions.InflatedPinnedLogNormal.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.LogNormal"><code class="flex name class">
<span>class <span class="ident">LogNormal</span></span>
<span>(</span><span>mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate log-normal distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</span><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mu</code></strong></dt>
<dd>Expected value of variable's log ( <span><span class="MathJax_Preview"> \mu </span><script type="math/tex"> \mu </script></span> ).</dd>
<dt><strong><code>sigma</code></strong></dt>
<dd>Standard deviation of variable log ( <span><span class="MathJax_Preview"> \sigma </span><script type="math/tex"> \sigma </script></span> ).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogNormal(pg.LogNormalDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate log-normal distribution supporting pseudo_counts.

    $$
    p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
        \exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
    $$
    &#34;&#34;&#34;

    name = &#34;LogNormalDistribution&#34;

    def __init__(
        self, mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0, **kwargs
    ):
        r&#34;&#34;&#34;
        Args:
            mu: Expected value of variable&#39;s log ( \( \mu \) ).
            sigma: Standard deviation of variable log ( \( \sigma \) ).
        &#34;&#34;&#34;
        super().__init__(mu, sigma, **kwargs)
        self.mu_ = mu
        self.sigma_ = sigma
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior mean and variance as if they were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            x2 = self.sigma_**2 + self.mu_**2
            self.summaries = [
                self.pseudo_count,
                self.mu_ * self.pseudo_count,
                x2 * self.pseudo_count,
            ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pomegranate.distributions.LogNormalDistribution.LogNormalDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="statkit.distributions.PinnedLogNormal" href="#statkit.distributions.PinnedLogNormal">PinnedLogNormal</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.LogNormal.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.PinnedLogNormal"><code class="flex name class">
<span>class <span class="ident">PinnedLogNormal</span></span>
<span>(</span><span>mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Log normal distribution where the standard deviation is held fixed to <span><span class="MathJax_Preview"> \sigma</span><script type="math/tex"> \sigma</script></span>.</p>
<p>Only the parameter <span><span class="MathJax_Preview"> \mu </span><script type="math/tex"> \mu </script></span> is infered from the data, the parameter <span><span class="MathJax_Preview"> \sigma </span><script type="math/tex"> \sigma </script></span>
is fixed after distribution initialisation.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</span><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
\exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mu</code></strong></dt>
<dd>Expected value of variable's log ( <span><span class="MathJax_Preview"> \mu </span><script type="math/tex"> \mu </script></span> ).</dd>
<dt><strong><code>sigma</code></strong></dt>
<dd>Standard deviation of variable log ( <span><span class="MathJax_Preview"> \sigma </span><script type="math/tex"> \sigma </script></span> ).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PinnedLogNormal(LogNormal):
    r&#34;&#34;&#34;Log normal distribution where the standard deviation is held fixed to \( \sigma\).

    Only the parameter \( \mu \) is infered from the data, the parameter \( \sigma \)
    is fixed after distribution initialisation.

    $$
    p(x) = \frac{1}{\sqrt{2\pi \sigma^2 x^2}}
        \exp \left( -\frac{(\ln x - \mu)^2}{2\sigma^2} \right).
    $$
    &#34;&#34;&#34;

    name = &#34;PinnedLogNormalDistribution&#34;

    def from_summaries(self, inertia: float = 0.0):
        &#34;&#34;&#34;Reset pinned standard deviation.&#34;&#34;&#34;
        super().from_summaries(inertia)
        self.parameters: list = [self.parameters[0], self.sigma_]
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="statkit.distributions.LogNormal" href="#statkit.distributions.LogNormal">LogNormal</a></li>
<li>pomegranate.distributions.LogNormalDistribution.LogNormalDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.PinnedLogNormal.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="statkit.distributions.PinnedLogNormal.from_summaries"><code class="name flex">
<span>def <span class="ident">from_summaries</span></span>(<span>self, inertia: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset pinned standard deviation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_summaries(self, inertia: float = 0.0):
    &#34;&#34;&#34;Reset pinned standard deviation.&#34;&#34;&#34;
    super().from_summaries(inertia)
    self.parameters: list = [self.parameters[0], self.sigma_]
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.Poisson"><code class="flex name class">
<span>class <span class="ident">Poisson</span></span>
<span>(</span><span>l: float = 1.0, pseudo_count: float = 0.0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Poisson supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{x^l e^{-l}}{x!}
</span><script type="math/tex; mode=display">
p(x) = \frac{x^l e^{-l}}{x!}
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>l</code></strong></dt>
<dd>Rate (and therefore, the mean) of the distribution.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Poisson(pg.PoissonDistribution):
    r&#34;&#34;&#34;Extension of Pomegranate Poisson supporting pseudo_counts.

    $$
    p(x) = \frac{x^l e^{-l}}{x!}
    $$
    &#34;&#34;&#34;

    name = &#34;PoissonDistribution&#34;

    def __init__(self, l: float = 1.0, pseudo_count: float = 0.0, **kwargs):
        &#34;&#34;&#34;
        Args:
            l: Rate (and therefore, the mean) of the distribution.
        &#34;&#34;&#34;
        super().__init__(l, **kwargs)
        self.pseudo_count = pseudo_count

        # Pseudo-count hack: compute summaries so that the next `fit` will weigh
        # the prior mean and variance as if they were coming from `pseudo_count`
        # observations.
        if self.pseudo_count &gt; 0:
            self.summaries = [
                # Nota bene: Here the order of the summaries is swapped compared to
                # other distributions.
                l * self.pseudo_count,
                self.pseudo_count,
            ]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pomegranate.distributions.PoissonDistribution.PoissonDistribution</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.Poisson.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.ZeroInflatedExponential"><code class="flex name class">
<span>class <span class="ident">ZeroInflatedExponential</span></span>
<span>(</span><span>pi: float = 0.5, rate: float = 1.0, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Exponential distribution with finite probability of value zero.</p>
<p>That is,
<span><span class="MathJax_Preview">
p(x) = \left \{ \begin{matrix}
\pi_0 \delta(x) &amp; x = 0, \\
\left(1 - \pi_0 \right) \lambda
e^{-\lambda x}
&amp; x \neq 0.
\end{matrix}
\right.
</span><script type="math/tex; mode=display">
p(x) = \left \{ \begin{matrix}
\pi_0 \delta(x) & x = 0, \\
\left(1 - \pi_0 \right) \lambda
e^{-\lambda x}
& x \neq 0.
\end{matrix}
\right.
</script></span></p>
<p>Initialise distribution with default values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pi</code></strong></dt>
<dd>Probability of observing the value zero ( <span><span class="MathJax_Preview"> \pi_0 </span><script type="math/tex"> \pi_0 </script></span> ).</dd>
<dt><strong><code>rate</code></strong></dt>
<dd>Inverse length scale <span><span class="MathJax_Preview"> \lambda </span><script type="math/tex"> \lambda </script></span>.</dd>
<dt><strong><code>pseudo_count</code></strong></dt>
<dd>Act like <code>pi</code> and <code>rate</code> were obtained from this many
observations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZeroInflatedExponential(_BaseZeroInflated):
    r&#34;&#34;&#34;Exponential distribution with finite probability of value zero.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_0 \delta(x) &amp; x = 0, \\
            \left(1 - \pi_0 \right) \lambda  e^{-\lambda x}  &amp; x \neq 0.
        \end{matrix}
        \right.
    $$
    &#34;&#34;&#34;

    ComplementaryDistribution = Exponential
    name = &#34;ZeroInflatedExponential&#34;

    def __init__(
        self,
        pi: float = 0.5,
        rate: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        r&#34;&#34;&#34;Initialise distribution with default values.

        Args:
            pi: Probability of observing the value zero ( \( \pi_0 \) ).
            rate: Inverse length scale \( \lambda \).
            pseudo_count: Act like `pi` and `rate` were obtained from this many
                observations.
        &#34;&#34;&#34;
        super().__init__(pi, rate, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseZeroInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.ZeroInflatedExponential.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate exponential distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \lambda \exp(-\lambda x).
</span><script type="math/tex; mode=display">
p(x) = \lambda \exp(-\lambda x).
</script></span></p></div>
</dd>
<dt id="statkit.distributions.ZeroInflatedExponential.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.ZeroInflatedGamma"><code class="flex name class">
<span>class <span class="ident">ZeroInflatedGamma</span></span>
<span>(</span><span>pi: float = 0.5, alpha: float = 1.0, beta: float = 1.0, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Gamma distribution with finite probability of observering zero.</p>
<p>That is,
<span><span class="MathJax_Preview">
p(x) = \left \{ \begin{matrix}
\pi_0 \delta(x) &amp; x = 0, \\
\left(1 - \pi_0 \right)
\frac{\beta^{\alpha}}{\Gamma(\alpha)} x^{\alpha-1} e^{-\beta x} &amp; x \neq 0.
\end{matrix}
\right.
</span><script type="math/tex; mode=display">
p(x) = \left \{ \begin{matrix}
\pi_0 \delta(x) & x = 0, \\
\left(1 - \pi_0 \right)
\frac{\beta^{\alpha}}{\Gamma(\alpha)} x^{\alpha-1} e^{-\beta x} & x \neq 0.
\end{matrix}
\right.
</script></span></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZeroInflatedGamma(_BaseZeroInflated):
    r&#34;&#34;&#34;Gamma distribution with finite probability of observering zero.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_0 \delta(x) &amp; x = 0, \\
            \left(1 - \pi_0 \right)
            \frac{\beta^{\alpha}}{\Gamma(\alpha)} x^{\alpha-1} e^{-\beta x} &amp; x \neq 0.
        \end{matrix}
        \right.
    $$
    &#34;&#34;&#34;

    ComplementaryDistribution = Gamma
    name = &#34;ZeroInflatedGamma&#34;

    def __init__(
        self,
        pi: float = 0.5,
        alpha: float = 1.0,
        beta: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        super().__init__(pi, alpha, beta, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseZeroInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.ZeroInflatedGamma.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Gamma distribution supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
</span><script type="math/tex; mode=display">
p(x) = \frac{\beta^\alpha}{\Gamma(\alpha)} x^{\alpha - 1} \exp[-\beta x].
</script></span></p></div>
</dd>
<dt id="statkit.distributions.ZeroInflatedGamma.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="statkit.distributions.ZeroInflatedGaussian"><code class="flex name class">
<span>class <span class="ident">ZeroInflatedGaussian</span></span>
<span>(</span><span>pi: float = 0.5, mu: float = 0.0, sigma: float = 1.0, pseudo_count: float = 0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Model p(x=0) with finite probability, and the remainder as Gaussian.</p>
<p>That is,
<span><span class="MathJax_Preview">
p(x) = \left \{ \begin{matrix}
\pi_0 \delta(x) &amp; x = 0, \\
\left(1 - \pi_0 \right) \frac{1}{\sqrt{2\pi \sigma^2} e^{-\frac{(x-\mu)^2}{2\sigma^2}}
&amp; x \neq 0.
\end{matrix}
\right.
</span><script type="math/tex; mode=display">
p(x) = \left \{ \begin{matrix}
\pi_0 \delta(x) & x = 0, \\
\left(1 - \pi_0 \right) \frac{1}{\sqrt{2\pi \sigma^2} e^{-\frac{(x-\mu)^2}{2\sigma^2}}
& x \neq 0.
\end{matrix}
\right.
</script></span></p>
<p>The mean of this distribution is:
<span><span class="MathJax_Preview">
(1-\pi_0) \mu.
</span><script type="math/tex; mode=display">
(1-\pi_0) \mu.
</script></span></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pi</code></strong></dt>
<dd>Probability <span><span class="MathJax_Preview"> \pi </span><script type="math/tex"> \pi </script></span> of observering a zero.</dd>
<dt><strong><code>mu</code></strong></dt>
<dd>Mean <span><span class="MathJax_Preview"> \mu </span><script type="math/tex"> \mu </script></span> of Gaussian.</dd>
<dt><strong><code>sigma</code></strong></dt>
<dd>Standard deviation <span><span class="MathJax_Preview"> \sigma </span><script type="math/tex"> \sigma </script></span> of Gaussian.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ZeroInflatedGaussian(_BaseZeroInflated):
    r&#34;&#34;&#34;Model p(x=0) with finite probability, and the remainder as Gaussian.

    That is,
    $$
        p(x) = \left \{ \begin{matrix}
            \pi_0 \delta(x) &amp; x = 0, \\
            \left(1 - \pi_0 \right) \frac{1}{\sqrt{2\pi \sigma^2} e^{-\frac{(x-\mu)^2}{2\sigma^2}}  &amp; x \neq 0.
        \end{matrix}
        \right.
    $$

    The mean of this distribution is:
    $$
    (1-\pi_0) \mu.
    $$
    &#34;&#34;&#34;

    ComplementaryDistribution = Gaussian
    name = &#34;ZeroInflatedGaussian&#34;

    def __init__(
        self,
        pi: float = 0.5,
        mu: float = 0.0,
        sigma: float = 1.0,
        pseudo_count: float = 0.0,
    ):
        r&#34;&#34;&#34;
        Args:
            pi: Probability \( \pi \) of observering a zero.
            mu: Mean \( \mu \) of Gaussian.
            sigma: Standard deviation \( \sigma \) of Gaussian.
        &#34;&#34;&#34;
        super().__init__(pi, mu, sigma, pseudo_count=pseudo_count)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>statkit.distributions._BaseZeroInflated</li>
<li>statkit.distributions._AbstractInflated</li>
<li>abc.ABC</li>
<li>pomegranate.distributions.distributions.Distribution</li>
<li>pomegranate.base.Model</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="statkit.distributions.ZeroInflatedGaussian.ComplementaryDistribution"><code class="name">var <span class="ident">ComplementaryDistribution</span></code></dt>
<dd>
<div class="desc"><p>Extension of Pomegranate Gaussian supporting pseudo_counts.</p>
<p><span><span class="MathJax_Preview">
p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
</span><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} e^{-\frac{(x-\mu)^2}{2\sigma^2}}.
</script></span></p></div>
</dd>
<dt id="statkit.distributions.ZeroInflatedGaussian.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="statkit" href="index.html">statkit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="statkit.distributions.Bernoulli" href="#statkit.distributions.Bernoulli">Bernoulli</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.Bernoulli.name" href="#statkit.distributions.Bernoulli.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.Discrete" href="#statkit.distributions.Discrete">Discrete</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.Discrete.log_probability" href="#statkit.distributions.Discrete.log_probability">log_probability</a></code></li>
<li><code><a title="statkit.distributions.Discrete.name" href="#statkit.distributions.Discrete.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.Exponential" href="#statkit.distributions.Exponential">Exponential</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.Exponential.name" href="#statkit.distributions.Exponential.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.Gamma" href="#statkit.distributions.Gamma">Gamma</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.Gamma.name" href="#statkit.distributions.Gamma.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.Gaussian" href="#statkit.distributions.Gaussian">Gaussian</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.Gaussian.name" href="#statkit.distributions.Gaussian.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.InflatedExponential" href="#statkit.distributions.InflatedExponential">InflatedExponential</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.InflatedExponential.ComplementaryDistribution" href="#statkit.distributions.InflatedExponential.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.InflatedExponential.name" href="#statkit.distributions.InflatedExponential.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.InflatedGamma" href="#statkit.distributions.InflatedGamma">InflatedGamma</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.InflatedGamma.ComplementaryDistribution" href="#statkit.distributions.InflatedGamma.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.InflatedGamma.name" href="#statkit.distributions.InflatedGamma.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.InflatedGaussian" href="#statkit.distributions.InflatedGaussian">InflatedGaussian</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.InflatedGaussian.ComplementaryDistribution" href="#statkit.distributions.InflatedGaussian.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.InflatedGaussian.name" href="#statkit.distributions.InflatedGaussian.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.InflatedLogNormal" href="#statkit.distributions.InflatedLogNormal">InflatedLogNormal</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.InflatedLogNormal.ComplementaryDistribution" href="#statkit.distributions.InflatedLogNormal.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.InflatedLogNormal.name" href="#statkit.distributions.InflatedLogNormal.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.InflatedPinnedLogNormal" href="#statkit.distributions.InflatedPinnedLogNormal">InflatedPinnedLogNormal</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.InflatedPinnedLogNormal.ComplementaryDistribution" href="#statkit.distributions.InflatedPinnedLogNormal.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.InflatedPinnedLogNormal.name" href="#statkit.distributions.InflatedPinnedLogNormal.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.LogNormal" href="#statkit.distributions.LogNormal">LogNormal</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.LogNormal.name" href="#statkit.distributions.LogNormal.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.PinnedLogNormal" href="#statkit.distributions.PinnedLogNormal">PinnedLogNormal</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.PinnedLogNormal.from_summaries" href="#statkit.distributions.PinnedLogNormal.from_summaries">from_summaries</a></code></li>
<li><code><a title="statkit.distributions.PinnedLogNormal.name" href="#statkit.distributions.PinnedLogNormal.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.Poisson" href="#statkit.distributions.Poisson">Poisson</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.Poisson.name" href="#statkit.distributions.Poisson.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.ZeroInflatedExponential" href="#statkit.distributions.ZeroInflatedExponential">ZeroInflatedExponential</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.ZeroInflatedExponential.ComplementaryDistribution" href="#statkit.distributions.ZeroInflatedExponential.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.ZeroInflatedExponential.name" href="#statkit.distributions.ZeroInflatedExponential.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.ZeroInflatedGamma" href="#statkit.distributions.ZeroInflatedGamma">ZeroInflatedGamma</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.ZeroInflatedGamma.ComplementaryDistribution" href="#statkit.distributions.ZeroInflatedGamma.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.ZeroInflatedGamma.name" href="#statkit.distributions.ZeroInflatedGamma.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="statkit.distributions.ZeroInflatedGaussian" href="#statkit.distributions.ZeroInflatedGaussian">ZeroInflatedGaussian</a></code></h4>
<ul class="">
<li><code><a title="statkit.distributions.ZeroInflatedGaussian.ComplementaryDistribution" href="#statkit.distributions.ZeroInflatedGaussian.ComplementaryDistribution">ComplementaryDistribution</a></code></li>
<li><code><a title="statkit.distributions.ZeroInflatedGaussian.name" href="#statkit.distributions.ZeroInflatedGaussian.name">name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>