{"version":3,"sources":["webpack:///./packages/hashi/src/xAPI/xAPISchema.js"],"names":["xAPIValidationError","message","fileName","lineNumber","instance","Error","name","Object","setPrototypeOf","getPrototypeOf","this","captureStackTrace","toNumber","value","NaN","Number","numericValid","r","split","RANGE_DELIMITER","start","end","startNumber","isUndefined","isNaN","endNumber","prototype","create","constructor","enumerable","writable","configurable","__proto__","numIFI","o","Boolean","mbox","mbox_sha1sum","openid","account","mboxRegex","msg","attr","sha1Validator","sha2Validator","arrayValidator","test","isArray","arrayOrObjectValidator","v","isPlainObject","booleanValidator","isBoolean","numberValidator","isNumber","objectValidator","stringValidator","isString","mimeTypeValidator","languageValidator","isLangCode","res","languageMapValidator","entries","every","k","s","IRIValidator","iri","IRI","scheme","hierpart","authority","IRLValidator","path","durationValidator","parseDuration","e","timestampValidator","dayjs","isValid","UUIDValidator","validateUUID","interactionTypeValidator","InteractionTypeChoices","has","noOptionsValidator","interactionOptionsLookup","interactionType","key","correctResponsesValidator","warn","correctResponsesPattern","INTERACTION_TYPES","TRUE_FALSE","CHOICE","SEQUENCING","choices","choiceIds","Set","map","c","id","OUTER_DELIMITER","MATCHING","source","target","sourceIds","targetIds","pair","INNER_DELIMITER","t","PERFORMANCE","steps","stepIds","LIKERT","scale","scaleIds","NUMERIC","FILL_IN","LONG_FILL_IN","objectTypeValidator","objectType","ObjectTypeChoices","noSubStatement","OBJECT_TYPES","SUBSTATEMENT","authorityTypeValidator","AGENT","GROUP","authorityOAuthValidator","member","length","contextPropertyValidator","ACTIVITY","context","revision","platform","minValidator","max","maxValidator","min","rawMinValidator","rawMaxValidator","versionValidator","parts","maj","pat","notAllowed","EnforceValue","obj","Schema","spec","output","keySpec","required","isFunction","default","validators","i","console","schema","clean","IFISpecFactory","ifiValidator","homePage","Agent","Group","Actor","Verb","display","InteractionComponent","description","ActivityDefinition","type","moreInfo","extensions","CMI_INTERACTION","Activity","definition","StatementRef","STATEMENTREF","ObjectSchema","SubStatement","Score","scaled","raw","Result","score","success","completion","response","duration","coerceToArray","Context","registration","instructor","team","group","contextActivities","parent","grouping","category","other","language","statement","Attachment","usageType","contentType","sha2","fileUrl","actor","verb","object","result","timestamp","attachments","stored","version","Statement","uuidv4"],"mappings":"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","file":"kolibri.plugins.html5_viewer.main-xAPISchema-0.15.12.js","sourcesContent":["/**\n * This module creates utilities for validating xAPI statements\n *\n * For more information, see:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md\n */\nimport 'core-js/features/set';\nimport isArray from 'lodash/isArray';\nimport isBoolean from 'lodash/isBoolean';\nimport isFunction from 'lodash/isFunction';\nimport isNumber from 'lodash/isNumber';\nimport isPlainObject from 'lodash/isPlainObject';\nimport isString from 'lodash/isString';\nimport isUndefined from 'lodash/isUndefined';\nimport { validate as validateUUID, v4 as uuidv4 } from 'uuid';\nimport { parse as parseDuration } from 'iso8601-duration';\nimport { IRI } from 'iri';\nimport dayjs from 'dayjs';\nimport { isLangCode } from 'is-language-code';\nimport {\n  OBJECT_TYPES,\n  ObjectTypeChoices,\n  INTERACTION_TYPES,\n  InteractionTypeChoices,\n  interactionOptionsLookup,\n  OUTER_DELIMITER,\n  INNER_DELIMITER,\n  RANGE_DELIMITER,\n  CMI_INTERACTION,\n} from './xAPIConstants';\n\n/*\n * Custom error to trigger when validation fails\n * Use ES5 compatible subclassing for compatibility.\n * Use this instead of a built in error to be sure\n * that validation errors in tests are actually because\n * of failed validation and not code errors.\n */\nexport function xAPIValidationError(message, fileName, lineNumber) {\n  var instance = new Error(message, fileName, lineNumber);\n  instance.name = 'xAPIValidationError';\n  Object.setPrototypeOf(instance, Object.getPrototypeOf(this));\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(instance, xAPIValidationError);\n  }\n  return instance;\n}\n\nxAPIValidationError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: Error,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  },\n});\n\nif (Object.setPrototypeOf) {\n  Object.setPrototypeOf(xAPIValidationError, Error);\n} else {\n  xAPIValidationError.__proto__ = Error;\n}\n\n/*\n * Utility functions to help with validation\n */\n\n/*\n * Number turns empty string into 0 and so\n * does lodash toNumber - we want to treat\n * blank string differently due to the semantics\n * of the xAPI/SCORM numeric format.\n */\nfunction toNumber(value) {\n  return value === '' ? NaN : Number(value);\n}\n\n/*\n * Helper function to parse the xAPI/SCORM numeric format\n * Can be a single digit, an unbounded range, or a bounded range\n * e.g.:\n * 7 - number 7\n * 7[:] - 7 and up\n * [:]7 - up to and including 7\n * 4[:]7 - 4 to 7 inclusive\n */\nfunction numericValid(r) {\n  const [start, end] = r.split(RANGE_DELIMITER);\n  const startNumber = toNumber(start);\n  // Single number only case, no delimiter used.\n  if (isUndefined(end)) {\n    return !isNaN(startNumber);\n  }\n  // If we have got here, there is a delimiter\n  const endNumber = toNumber(end);\n  if (start === '') {\n    // Range unbounded on the lower end\n    return !isNaN(endNumber);\n  }\n  if (end === '') {\n    // Range unbounded on the upper end\n    return !isNaN(startNumber);\n  }\n  if (!isNaN(startNumber) && !isNaN(endNumber)) {\n    // Both are numbers, so just check that this is\n    // a valid range.\n    return startNumber < endNumber;\n  }\n  // No other success cases, so must have failed.\n  return false;\n}\n\n/*\n * Calculate how many mutually exclusive IFI fields have been defined\n * on an object.\n */\nconst numIFI = o =>\n  Boolean(o.mbox) + Boolean(o.mbox_sha1sum) + Boolean(o.openid) + Boolean(o.account);\n\n/*\n * Validator objects.\n * Most of the validator objects are plain objects with a\n * test and msg method - test returns true or false for whether\n * the attribute passes validation, msg returns the error message\n *\n * test accepts up to three parameters - value, key, and whole object\n * msg accepts up to two parameters - key, and whole object\n * warn - an optional boolean property, if true, this will only log a warning\n *        and not fail validation - useful for properties that MAY be enforced in the spec\n */\n\n/*\n * The first validators are just Javascript Regex objects that have an\n * additional msg method defined on them, so already have the test method\n * defined.\n */\n\nconst mboxRegex = /^mailto:[^@]+@[^@]+$/;\nmboxRegex.msg = attr => `${attr} does not start with mailto: or is not a valid email address`;\n\n// SHA-1 Hashes have a bit length of 160, giving a 40 digit hex\nconst sha1Validator = /^[a-f0-9]{40}$/;\nsha1Validator.msg = attr => `${attr} is not a valid SHA1 sum`;\n\n/*\n * SHA-2 is a family of hash functions:\n * SHA-224 - bit length 224, 56 digit hex\n * SHA-256 - bit length 256, 64 digit hex\n * SHA-384 - bit length 384, 96 digit hex\n * SHA-512 - bit length 512, 128 digit hex\n * SHA-512/224 - bit length 224, 56 digit hex\n * SHA-512/256 - bit length 256, 64 digit hex\n */\nconst sha2Validator = /^([a-f0-9]{56}|[a-f0-9]{64}|[a-f0-9]{96}|[a-f0-9]{128})$/;\nsha2Validator.msg = attr => `${attr} is not a valid SHA2 hash`;\n\n/*\n * Validators for basic Javascript types\n * These will often be used in conjunction with other\n * validators to prevent having to type check in subsequent validation\n */\n\nconst arrayValidator = {\n  test: isArray,\n  msg: attr => `${attr} must be an array`,\n};\n\nconst arrayOrObjectValidator = {\n  test: v => isArray(v) || isPlainObject(v),\n  msg: attr => `${attr} must be an array or object`,\n};\n\nconst booleanValidator = {\n  test: isBoolean,\n  msg: attr => `${attr} must be a boolean`,\n};\n\nconst numberValidator = {\n  test: isNumber,\n  msg: attr => `${attr} must be a number`,\n};\n\nconst objectValidator = {\n  test: isPlainObject,\n  msg: attr => `${attr} must be an object`,\n};\n\nconst stringValidator = {\n  test: isString,\n  msg: attr => `${attr} must be a string`,\n};\n\n/*\n * Additional 'primitive' types defined here:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#special-data\n * and in various ietf.org RFCs\n */\n\nconst mimeTypeValidator = /\\w+\\/[-.\\w]+(?:\\+[-.\\w]+)?/;\nmimeTypeValidator.msg = attr => `${attr} is not a valid mimetype`;\n\nconst languageValidator = {\n  test: v => isLangCode(v).res,\n  msg: (attr, o) => `${attr} is not a valid language code because: ${isLangCode(o[attr]).message}`,\n};\n\nconst languageMapValidator = {\n  test: v => Object.entries(v).every(([k, s]) => isLangCode(k).res && isString(s)),\n  msg: attr => `${attr} is not a valid LanguageMap`,\n};\n\nconst IRIValidator = {\n  test: v => {\n    const iri = new IRI(v);\n    return iri.scheme() && iri.hierpart() && iri.authority();\n  },\n  msg: attr => `${attr} is not a valid IRI`,\n};\n\nconst IRLValidator = {\n  test: v => {\n    const iri = new IRI(v);\n    return (iri.scheme() && iri.hierpart() && iri.authority()) || iri.path();\n  },\n  msg: attr => `${attr} is not a valid IRL`,\n};\n\nconst durationValidator = {\n  test: v => {\n    try {\n      parseDuration(v);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  },\n  msg: attr => `${attr} must be an ISO 8601 duration`,\n};\n\nconst timestampValidator = {\n  test: v => {\n    const d = dayjs(v);\n    return d.isValid();\n  },\n  msg: attr => `${attr} must be an ISO 8601 timestamp`,\n};\n\nconst UUIDValidator = {\n  test: validateUUID,\n  msg: attr => `${attr} must be a valid UUID`,\n};\n\n/*\n * These validators are specific to encoding SCORM based CMI interaction types.\n * Detailed here: https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#interaction-activities\n */\n\nconst interactionTypeValidator = {\n  test: v => InteractionTypeChoices.has(v),\n  msg: attr => `${attr} was set as an invalid interaction type`,\n};\n\n/*\n * Some interaction types do not take any other parameters\n * and the specification enforces that these should not be passed\n * alongside these types - this validator enforces that.\n */\nconst noOptionsValidator = {\n  test: (v, k, o) => {\n    return interactionOptionsLookup[k].has(o.interactionType);\n  },\n  msg: (key, o) => `${key} specified but ${o.interactionType} does not support it`,\n};\n\n/*\n * This validates the correctResponses property - ensuring that\n * correctResponses are accurate when compared to the available\n * responses to the interaction.\n */\nconst correctResponsesValidator = {\n  warn: true,\n  test: (v, k, o) => {\n    const interactionType = o.interactionType;\n    const correctResponsesPattern = o.correctResponsesPattern;\n    if (interactionType === INTERACTION_TYPES.TRUE_FALSE) {\n      return correctResponsesPattern.every(r => r === 'true' || r === 'false');\n    }\n    if (\n      interactionType === INTERACTION_TYPES.CHOICE ||\n      interactionType === INTERACTION_TYPES.SEQUENCING\n    ) {\n      const choices = o.choices;\n      const choiceIds = new Set(choices.map(c => c.id));\n      return correctResponsesPattern.every(r => {\n        const ids = r.split(OUTER_DELIMITER);\n        return ids.every(id => choiceIds.has(id));\n      });\n    }\n    if (interactionType === INTERACTION_TYPES.MATCHING) {\n      const source = o.source;\n      const target = o.target;\n      const sourceIds = new Set(source.map(c => c.id));\n      const targetIds = new Set(target.map(c => c.id));\n      return correctResponsesPattern.every(r => {\n        const pairs = r.split(OUTER_DELIMITER);\n        return pairs.every(pair => {\n          const [s, t] = pair.split(INNER_DELIMITER);\n          return sourceIds.has(s) && targetIds.has(t);\n        });\n      });\n    }\n    if (interactionType === INTERACTION_TYPES.PERFORMANCE) {\n      const steps = o.steps;\n      const stepIds = new Set(steps.map(c => c.id));\n      return correctResponsesPattern.every(r => {\n        const pairs = r.split(OUTER_DELIMITER);\n        return pairs.every(pair => {\n          const [s] = pair.split(INNER_DELIMITER);\n          return stepIds.has(s);\n        });\n      });\n    }\n    if (interactionType === INTERACTION_TYPES.LIKERT) {\n      const scale = o.scale;\n      const scaleIds = new Set(scale.map(c => c.id));\n      return correctResponsesPattern.every(r => scaleIds.has(r));\n    }\n    if (interactionType === INTERACTION_TYPES.NUMERIC) {\n      return correctResponsesPattern.every(numericValid);\n    }\n    return true;\n  },\n  msg: (key, o) => {\n    const interactionType = o.interactionType;\n    if (interactionType === INTERACTION_TYPES.TRUE_FALSE) {\n      return 'true-false must take either true or false as the answer';\n    }\n    if (\n      interactionType === INTERACTION_TYPES.CHOICE ||\n      interactionType === INTERACTION_TYPES.SEQUENCING\n    ) {\n      return `${interactionType} must only use choice ids from the item`;\n    }\n    if (\n      interactionType === INTERACTION_TYPES.FILL_IN ||\n      interactionType === INTERACTION_TYPES.LONG_FILL_IN\n    ) {\n      return `${interactionType} must have no non blank answers`;\n    }\n    if (interactionType === INTERACTION_TYPES.MATCHING) {\n      return 'matching must only use source and target ids from the item';\n    }\n    if (interactionType === INTERACTION_TYPES.PERFORMANCE) {\n      return 'performance must only use step ids and fill-in or numeric responses';\n    }\n    if (interactionType === INTERACTION_TYPES.LIKERT) {\n      return `${interactionType} must only use scale ids from the item`;\n    }\n    if (interactionType === INTERACTION_TYPES.NUMERIC) {\n      return `${interactionType} must have valid numeric responses`;\n    }\n  },\n};\n\n/*\n * Validators specific to enforcing the correct objectType for objects\n * and ensuring that appropriate parameters are set depending on the objectType\n */\nconst objectTypeValidator = {\n  test: v => isUndefined(v.objectType) || ObjectTypeChoices.has(v.objectType),\n  msg: () => 'objectType must either be undefined or an allowed value',\n};\n\nconst noSubStatement = {\n  test: v => !v.objectType || v.objectType !== OBJECT_TYPES.SUBSTATEMENT,\n  msg: () => 'object cannot be a SubStatement',\n};\n\nconst authorityTypeValidator = {\n  test: v => v.objectType === OBJECT_TYPES.AGENT || v.objectType === OBJECT_TYPES.GROUP,\n  msg: () => 'authority must either be an Agent or a Group',\n};\n\nconst authorityOAuthValidator = {\n  test: v => v.objectType !== OBJECT_TYPES.GROUP || v.member.length === 2,\n  msg: () => 'if authority is a group, must specify two member Agents',\n};\n\nconst contextPropertyValidator = {\n  /*\n   * The \"revision\" Context property MUST only be used if the Statement's Object is an Activity.\n   * The \"platform\" Context property MUST only be used if the Statement's Object is an Activity.\n   */\n  test: (v, k, o) => {\n    // Object is an activity if it has no defined objectType or explicitly set as one\n    if (isUndefined(v.objectType) || v.objectType === OBJECT_TYPES.ACTIVITY) {\n      // In this case, no further validation needed.\n      return true;\n    }\n    // Check that context does not have either for these values\n    return (\n      isUndefined(o.context) || (isUndefined(o.context.revision) && isUndefined(o.context.platform))\n    );\n  },\n};\n\n/*\n * Enforce no whitespace\n */\nconst noWhiteSpaceValidator = {\n  test: v => !/\\s/.test(v),\n  msg: attr => `${attr} must not contain whitespace`,\n};\n\n/*\n * Score object validators\n */\nconst scaledValidator = {\n  test: v => -1 <= v && 1 >= v,\n  msg: attr => `${attr} must be in the range -1 to 1 inclusive`,\n};\n\nconst minValidator = {\n  test: (v, k, o) => isUndefined(o.max) || v < o.max,\n  msg: () => `min must be less than max`,\n};\n\nconst maxValidator = {\n  test: (v, k, o) => isUndefined(o.min) || v > o.min,\n  msg: () => `max must be greater than min`,\n};\n\nconst rawMinValidator = {\n  test: (v, k, o) => isUndefined(o.min) || v >= o.min,\n  msg: () => 'raw must be greater than or equal to min',\n};\n\nconst rawMaxValidator = {\n  test: (v, k, o) => isUndefined(o.max) || v <= o.max,\n  msg: () => 'raw must be less than or equal to max',\n};\n\n/*\n * Validation of the version property of the Statement object\n */\nconst versionValidator = {\n  test: v => {\n    const parts = v.split('.').map(toNumber);\n    const [maj, min, pat] = parts;\n    if (parts.length === 3 && !isNaN(maj) && !isNaN(min) && !isNaN(pat)) {\n      return maj === 1 && min === 0;\n    }\n    return false;\n  },\n  msg: () => 'version must begin with 1.0 and be a semantic version',\n};\n\n/*\n * Use this to enforce properties that are explicitly _not_ allowed\n */\nconst notAllowed = {\n  test: () => false,\n  msg: attr => `${attr} was set but is not allowed`,\n};\n\n/*\n * Helper class to generate a validator that enforces a specific value\n */\nclass EnforceValue {\n  constructor(value) {\n    this.value = value;\n  }\n\n  test(v) {\n    return v === this.value;\n  }\n\n  msg(attr, obj) {\n    return `${attr} value did not match ${this.value} received ${obj[attr]}`;\n  }\n}\n\n/*\n * This is the main class that drives validation.\n * Its constructor takes a single argument which is the specification\n * of the schema that is going to be validated against.\n * It has a single method 'clean' that iterates over this specification\n * and checks the passed in object against this specification.\n *\n * A specification is in this format:\n *\n * {\n *   keyname: {\n *     required:   Boolean|Function\n *                 whether this keyname is required or not, defaults to false,\n *                 if it is a Function it will be called with arguments:\n *                 value, key, object and should return a Boolean result.\n *     validators: Array\n *                 an Array of validators - objects with methods test and msg\n *                 these are applied in the order specified in the Array,\n *                 and an xAPIValidationError will be thrown as soon as one\n *                 fails.\n *     schema:     Schema|Function\n *                 A Schema to use for further cleaning. If it is a function,\n *                 it will be invoked with arguments value, key, object and\n *                 should return a Schema object. The Schema object will then\n *                 have its clean method called either on the value directly,\n *                 or if the value is an Array, it is called on each object\n *                 in the Array and an Array of results returned.\n *     clean:      Function that takes the output of any Schema based cleaning\n *                 and allows that to be updated. This is currently only used\n *                 to turn a single object into an array with one object to\n *                 handle legacy data requirements in xAPI:\n *                 https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#requirements-11\n *     default:    Function\n *                 If the value is not found on the object, this function will\n *                 be invoked to create the value.\n *   }\n * }\n *\n *\n */\nclass Schema {\n  constructor(spec) {\n    this.spec = spec;\n  }\n  clean(obj) {\n    const output = {};\n    for (let key in this.spec) {\n      const keySpec = this.spec[key];\n      let required = keySpec.required;\n      if (isFunction(required)) {\n        required = required(obj);\n      }\n      if (required && isUndefined(obj[key])) {\n        throw new xAPIValidationError(`${key} required but not found`);\n      }\n      if (!isUndefined(obj[key])) {\n        const validators = keySpec.validators || [];\n        for (let i = 0; i < validators.length; i++) {\n          const v = validators[i];\n          if (!v.test(obj[key], key, obj)) {\n            const msg = v.msg(key, obj);\n            if (v.warn) {\n              console.warn(msg);\n            } else {\n              throw new xAPIValidationError(msg);\n            }\n          }\n        }\n        let schema = keySpec.schema;\n        if (isFunction(schema)) {\n          schema = schema(obj[key], key, obj);\n        }\n        if (schema && schema instanceof Schema) {\n          try {\n            if (isArray(obj[key])) {\n              output[key] = obj[key].map(o => schema.clean(o));\n            } else {\n              output[key] = schema.clean(obj[key]);\n            }\n          } catch (e) {\n            // Catch errors and rethrow to add path context to error message\n            throw new xAPIValidationError(`in ${key}: ${e.message}`);\n          }\n        } else {\n          output[key] = obj[key];\n        }\n        if (keySpec.clean) {\n          output[key] = keySpec.clean(output[key]);\n        }\n      } else if (keySpec.default && isFunction(keySpec.default)) {\n        output[key] = keySpec.default();\n      }\n    }\n    return output;\n  }\n}\n\n/*\n * Helper function to create a specification for IFI validation\n * which is used both for Agent and Group objects.\n * More info on IFI fields here:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#inversefunctional\n */\nfunction IFISpecFactory(required) {\n  let ifiValidator;\n  if (required) {\n    ifiValidator = {\n      test: (v, k, o) => numIFI(o) === 1,\n      msg: () => 'Did not supply exactly one IFI',\n    };\n  } else {\n    ifiValidator = {\n      test: (v, k, o) => numIFI(o) < 2,\n      msg: () => 'Supplied more than one IFI',\n    };\n  }\n  return {\n    mbox: {\n      required: o => !o.mbox_sha1sum && !o.openid && !o.account,\n      validators: [ifiValidator, stringValidator, mboxRegex],\n    },\n    mbox_sha1sum: {\n      required: o => !o.mbox && !o.openid && !o.account,\n      validators: [ifiValidator, stringValidator, sha1Validator],\n    },\n    openid: {\n      required: o => !o.mbox && !o.mbox_sha1sum && !o.account,\n      validators: [ifiValidator, stringValidator],\n    },\n    account: {\n      required: o => !o.mbox && !o.mbox_sha1sum && !o.openid,\n      validators: [ifiValidator],\n      schema: new Schema({\n        homePage: {\n          required: true,\n          validators: [stringValidator],\n        },\n        name: {\n          required: true,\n          validators: [stringValidator],\n        },\n      }),\n    },\n  };\n}\n\n/*\n * Schema definitions for Actor objects, can either be an Agent\n * for an individual or Group for multiple users.\n */\n\nexport const Agent = new Schema({\n  objectType: {\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.AGENT)],\n  },\n  name: {\n    validators: [stringValidator],\n  },\n  ...IFISpecFactory(true),\n});\n\nexport const Group = new Schema({\n  objectType: {\n    required: true,\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.GROUP)],\n  },\n  member: {\n    required: obj => !numIFI(obj),\n    validators: [arrayValidator],\n    schema: Agent,\n  },\n  name: {\n    validators: [stringValidator],\n  },\n  ...IFISpecFactory(false),\n});\n\nconst Actor = o => (o.objectType === OBJECT_TYPES.GROUP ? Group : Agent);\n\n/*\n * Verb definition:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#243-verb\n */\nexport const Verb = new Schema({\n  id: {\n    required: true,\n    validators: [stringValidator, IRIValidator],\n  },\n  display: {\n    validators: [objectValidator],\n  },\n});\n\n/*\n * Schema definitions for Object types not already defined above:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#244-object\n */\n\n/*\n * Used to define data about responses in CMI interaction types:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#interaction-components\n */\nconst InteractionComponent = new Schema({\n  id: {\n    required: true,\n    validators: [stringValidator, noWhiteSpaceValidator],\n  },\n  description: {\n    validators: [objectValidator, languageMapValidator],\n  },\n});\n\n/*\n * ActivityDefinition Schema, used for defining\n * activities, with specific additional information\n * for SCORM CMI activities:\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#activity-definition\n */\nexport const ActivityDefinition = new Schema({\n  name: {\n    validators: [objectValidator, languageMapValidator],\n  },\n  description: {\n    validators: [objectValidator, languageMapValidator],\n  },\n  type: {\n    validators: [stringValidator, IRIValidator],\n  },\n  moreInfo: {\n    validators: [stringValidator, IRLValidator],\n  },\n  extensions: {\n    validators: [objectValidator],\n  },\n  interactionType: {\n    required: o => o.type === CMI_INTERACTION,\n    validators: [stringValidator, interactionTypeValidator],\n  },\n  choices: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj =>\n      obj.interactionType === INTERACTION_TYPES.CHOICE ||\n      obj.interactionType === INTERACTION_TYPES.SEQUENCING,\n  },\n  source: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.MATCHING,\n  },\n  target: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.MATCHING,\n  },\n  steps: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.PERFORMANCE,\n  },\n  scale: {\n    schema: InteractionComponent,\n    validators: [noOptionsValidator, arrayValidator],\n    required: obj => obj.interactionType === INTERACTION_TYPES.LIKERT,\n  },\n  correctResponsesPattern: {\n    validators: [arrayValidator, correctResponsesValidator],\n  },\n});\n\n/*\n * Activity Schema definition - used to describe activities that\n * statements are about.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#2441-when-the-objecttype-is-activity\n */\nexport const Activity = new Schema({\n  id: {\n    validators: [stringValidator, IRIValidator],\n  },\n  objectType: {\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.ACTIVITY)],\n  },\n  definition: {\n    schema: ActivityDefinition,\n  },\n});\n\n/*\n * StatementRef Schema - used to refer to another statement\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#statement-references\n */\nexport const StatementRef = new Schema({\n  id: {\n    validators: [UUIDValidator],\n  },\n  objectType: {\n    validators: [stringValidator, new EnforceValue(OBJECT_TYPES.STATEMENTREF)],\n  },\n});\n\n/*\n * Helper function to return the correct Schema object depending\n * on the specified objectType value.\n */\nexport const ObjectSchema = o => {\n  const objectType = o.objectType;\n  if (!objectType || objectType === OBJECT_TYPES.ACTIVITY) {\n    return Activity;\n  }\n  if (objectType === OBJECT_TYPES.AGENT) {\n    return Agent;\n  }\n  if (objectType === OBJECT_TYPES.GROUP) {\n    return Group;\n  }\n  if (objectType === OBJECT_TYPES.STATEMENTREF) {\n    return StatementRef;\n  }\n  if (objectType === OBJECT_TYPES.SUBSTATEMENT) {\n    return SubStatement;\n  }\n};\n\n/*\n * Score Schema - used to describe the score of a result in a statement.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#2451-score\n */\nexport const Score = new Schema({\n  scaled: {\n    validators: [numberValidator, scaledValidator],\n  },\n  min: {\n    validators: [numberValidator, minValidator],\n  },\n  max: {\n    validators: [numberValidator, maxValidator],\n  },\n  raw: {\n    validators: [numberValidator, rawMinValidator, rawMaxValidator],\n  },\n});\n\n/*\n * Result Schema - used to describe results from interactions.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#245-result\n */\nexport const Result = new Schema({\n  score: {\n    schema: Score,\n  },\n  success: {\n    validators: [booleanValidator],\n  },\n  completion: {\n    validators: [booleanValidator],\n  },\n  response: {\n    validators: [stringValidator],\n  },\n  duration: {\n    validators: [durationValidator],\n  },\n  extensions: {\n    validators: [objectValidator],\n  },\n});\n\n// Helper function to return an object wrapped in an array if not already an array\nconst coerceToArray = o => (isArray(o) ? o : [o]);\n\n/*\n * Context Schema - used to provide additional context to a Statement.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#246-context\n */\nexport const Context = new Schema({\n  registration: {\n    validators: [UUIDValidator],\n  },\n  instructor: {\n    schema: Agent,\n  },\n  team: {\n    group: Group,\n  },\n  contextActivities: {\n    schema: new Schema({\n      parent: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n      grouping: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n      category: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n      other: {\n        schema: Activity,\n        validators: [arrayOrObjectValidator],\n        clean: coerceToArray,\n      },\n    }),\n  },\n  revision: {\n    validators: [stringValidator],\n  },\n  platform: {\n    validators: [stringValidator],\n  },\n  language: {\n    validators: [stringValidator, languageValidator],\n  },\n  statement: {\n    schema: StatementRef,\n  },\n  extensions: {\n    validators: [objectValidator],\n  },\n});\n\n/*\n * Attachment Schema - used to describe information about file\n * attachments associated with the statement.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#2411-attachments\n */\nexport const Attachment = new Schema({\n  usageType: {\n    required: true,\n    validators: [IRIValidator],\n  },\n  display: {\n    required: true,\n    validators: [objectValidator, languageMapValidator],\n  },\n  description: {\n    validators: [objectValidator, languageMapValidator],\n  },\n  contentType: {\n    required: true,\n    validators: [stringValidator, mimeTypeValidator],\n  },\n  length: {\n    required: true,\n    validators: [numberValidator],\n  },\n  sha2: {\n    required: true,\n    validators: [stringValidator, sha2Validator],\n  },\n  fileUrl: {\n    validators: [stringValidator, IRLValidator],\n  },\n});\n\n/* SubStatement Schema - used to create a statement that is nested inside another\n * another statement as an object.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#substatements\n */\nexport const SubStatement = new Schema({\n  id: {\n    validators: [notAllowed],\n  },\n  objectType: {\n    required: true,\n    validators: [new EnforceValue(OBJECT_TYPES.SUBSTATEMENT)],\n  },\n  actor: {\n    required: true,\n    schema: Actor,\n  },\n  verb: {\n    required: true,\n    schema: Verb,\n  },\n  object: {\n    required: true,\n    validators: [objectTypeValidator, noSubStatement],\n    schema: ObjectSchema,\n  },\n  result: {\n    schema: Result,\n  },\n  context: {\n    schema: Context,\n  },\n  timestamp: {\n    validators: [timestampValidator],\n  },\n  attachments: {\n    schema: Attachment,\n    validators: [arrayValidator],\n  },\n  stored: {\n    validators: [notAllowed],\n  },\n  version: {\n    validators: [notAllowed],\n  },\n  authority: {\n    validators: [notAllowed],\n  },\n});\n\n/*\n * Statement Schema - the top level object and main entry\n * point for validation.\n * https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#statements\n */\nexport const Statement = new Schema({\n  id: {\n    validators: [UUIDValidator],\n    default: uuidv4,\n  },\n  actor: {\n    required: true,\n    schema: Actor,\n  },\n  verb: {\n    required: true,\n    schema: Verb,\n  },\n  object: {\n    required: true,\n    validators: [objectTypeValidator, contextPropertyValidator],\n    schema: ObjectSchema,\n  },\n  result: {\n    schema: Result,\n  },\n  context: {\n    schema: Context,\n  },\n  timestamp: {\n    validators: [timestampValidator],\n  },\n  // We deliberately exclude the stored value here as it should only be supplied by the LRS\n  // so we ignore anything coming in from the statement creator - this will then be set either\n  // by us in the client side, or on the server when the statement is saved.\n  authority: {\n    schema: Actor,\n    validators: [authorityTypeValidator, authorityOAuthValidator],\n  },\n  version: {\n    validators: [stringValidator, versionValidator],\n    default: () => '1.0.0',\n  },\n  attachments: {\n    schema: Attachment,\n    validators: [arrayValidator],\n  },\n});\n"],"sourceRoot":""}