{"version":3,"sources":["webpack:///./packages/hashi/src/H5P/H5PRunner.js","webpack:///./packages/hashi/src/H5P/loadBinary.js"],"names":["Zip","file","this","zipfile","filter","Promise","resolve","reject","unzip","err","unzipped","Object","entries","map","name","obj","filename","_getFiles","then","files","path","startsWith","doNotLogVerbMap","doNotLogVerb","XAPIVerbMap","debounceVerbs","completionVerbMap","completionVerb","createBlobUrl","uint8array","fileName","type","fileNameExt","split","slice","ext","toLowerCase","mimetypes","blob","Blob","buffer","URL","createObjectURL","cssPathRegex","replacePaths","dep","packageFiles","replace","match","p1","p2","p3","pathname","substring","newUrl","e","console","debug","metadataKeys","H5PRunner","shim","data","scriptLoader","bind","iframe","filepath","loaded","errored","dependencies","jsDependencies","cssDependencies","contentPaths","contentJson","library","loadedJs","loadedCss","src","H5PFilename","zipcontentUrl","lastIndexOf","window","location","href","contentNamespace","start","performance","now","xhr","XMLHttpRequest","open","responseType","onreadystatechange","readyState","status","Uint8Array","response","Error","statusText","send","zip","recurseDependencies","setDependencies","processFiles","metadata","pick","rootConfig","processCssDependencies","processJsDependencies","contentDocument","contentWindow","H5P","initH5P","addEventListener","stateUpdated","shimH5P","cssURL","javascriptURL","init","setTimeout","instances","instance","trigger","div","document","createElement","classList","add","setAttribute","body","appendChild","originalGetPath","getPath","self","contentId","substr","length","getContentPath","getUserData","dataId","done","subContentId","get","undefined","setUserData","errorCallback","JSON","stringify","isFunction","set","deleteUserData","unset","originalContentType","ContentType","isRoot","ct","prototype","getLibraryFilePath","filePath","url","libraryInfo","versionedNameNoSpaces","XAPIEvent","setActor","xAPI","prepareStatement","statement","debouncedHandlers","debouncedVerb","verb","debounce","sendStatement","catch","error","debounceDelay","leading","maxWait","maxDelay","externalDispatcher","on","event","object","id","H5PContentIdentifier","progressed","source","integrationShim","jsonContent","fullScreen","displayOptions","copyright","download","embed","export","frame","icon","contentUserData","exportUrl","embedCode","resizeCode","mainId","title","styles","keys","scripts","l10n","userData","userFullName","mail","defineProperty","value","configurable","css","iframeDocument","script","rel","async","dependencySorter","Toposort","dependency","packagePath","preloadedCss","preloadedJs","sortedDependencies","sort","reverse","jsonFile","root","visitedPaths","json","parse","strFromU8","preloadedDependencies","all","depPackagePath","machineName","majorVersion","minorVersion","mainLibrary","js","push","concatenatedJS","reduce","wholeJS","allJs","jsDep","concatenatedCSS","wholeCSS","allCss","cssDep","jsFile","indexOf","contentFiles","processContent","processPackageFile"],"mappings":"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","file":"kolibri.plugins.learn.app-H5PRunner-0.15.12.js","sourcesContent":["import get from 'lodash/get';\nimport isFunction from 'lodash/isFunction';\nimport pick from 'lodash/pick';\nimport set from 'lodash/set';\nimport debounce from 'lodash/debounce';\nimport unset from 'lodash/unset';\nimport Toposort from 'toposort-class';\nimport { unzip, strFromU8 } from 'fflate';\nimport { filename as H5PFilename } from '../../h5p_build.json';\nimport mimetypes from '../mimetypes.json';\nimport { XAPIVerbMap } from '../xAPI/xAPIVocabulary';\nimport loadBinary from './loadBinary';\n\nclass Zip {\n  constructor(file) {\n    this.zipfile = file;\n  }\n\n  _getFiles(filter) {\n    return new Promise((resolve, reject) => {\n      unzip(this.zipfile, { filter }, (err, unzipped) => {\n        if (err) {\n          reject(err);\n        }\n        resolve(Object.entries(unzipped).map(([name, obj]) => ({ name, obj })));\n      });\n    });\n  }\n\n  file(filename) {\n    return this._getFiles(file => file.name === filename).then(files => files[0]);\n  }\n  files(path) {\n    return this._getFiles(file => file.name.startsWith(path));\n  }\n}\n\nconst CONTENT_ID = '1234567890';\n\n// Verbs that we simply will not report on.\nconst doNotLogVerbs = [\n  'downloaded',\n  'copied',\n  'accessed-reuse',\n  'accessed-embed',\n  'accessed-copyright',\n];\nconst doNotLogVerbMap = {};\nfor (let doNotLogVerb of doNotLogVerbs) {\n  doNotLogVerbMap[XAPIVerbMap[doNotLogVerb]] = true;\n}\n// These verbs are reported too much by H5P leading to spammy responses,\n// so we debounce logging of these responses.\nconst debounceVerbs = ['answered', 'interacted'];\n// Time in seconds to debounce by.\nconst debounceDelay = 5;\n// Max time that debounce should delay by.\nconst maxDelay = 30;\n\nconst completionVerbs = ['completed', 'mastered', 'passed'];\nconst completionVerbMap = {};\nfor (let completionVerb of completionVerbs) {\n  completionVerbMap[XAPIVerbMap[completionVerb]] = true;\n}\n\nfunction contentIdentifier(contentId) {\n  return `cid-${contentId}`;\n}\n\n/*\n * Create a blob and URL for a uint8array\n * set the mimetype and return the URL\n */\nfunction createBlobUrl(uint8array, fileName) {\n  let type = '';\n  const fileNameExt = fileName.split('.').slice(-1)[0];\n  if (fileNameExt) {\n    const ext = fileNameExt.toLowerCase();\n    type = mimetypes[ext];\n  }\n  const blob = new Blob([uint8array.buffer], { type });\n  return URL.createObjectURL(blob);\n}\n\n// Looks for any URLs referenced inside url()\nconst cssPathRegex = /(url\\(['\"]?)([^\"')]+)?(['\"]?\\))/g;\n\nexport function replacePaths(dep, packageFiles) {\n  return packageFiles[dep].replace(cssPathRegex, function(match, p1, p2, p3) {\n    try {\n      // Construct a URL with a dummy base so that we can concatenate the\n      // dependency URL with the URL relative to the dependency\n      // and then read the pathname to get the new path.\n      // Take substring to remove the leading slash to match the reference file paths\n      // in packageFiles.\n      const path = new URL(p2, new URL(dep, 'http://b.b/')).pathname.substring(1);\n      // Look to see if there is a URL in our packageFiles mapping that\n      // that has this as the source path.\n      const newUrl = packageFiles[path];\n      if (newUrl) {\n        // If so, replace the instance with the new URL.\n        return `${p1}${newUrl}${p3}`;\n      }\n    } catch (e) {\n      console.debug('Error during URL handling', e); // eslint-disable-line no-console\n    }\n    // Otherwise just return the match so that it is unchanged.\n    return match;\n  });\n}\n\nconst metadataKeys = [\n  'title',\n  'a11yTitle',\n  'authors',\n  'changes',\n  'source',\n  'license',\n  'licenseVersion',\n  'licenseExtras',\n  'authorComments',\n  'yearFrom',\n  'yearTo',\n  'defaultLanguage',\n];\n\n/*\n * Class that manages loading, parsing, and running an H5P file.\n * Loads the entire H5P file to the frontend, and then unzips, parses,\n * and turns each file into a Blob and generates a URL for that blob.\n * (this is the same mechanism that EpubJS uses to render Epubs in the frontend).\n * We mirror the path substitution done in the PHP implementation for\n * CSS concatenation, to ensure that all relatively referenced assets\n * in CSS files are instead referenced by their new Blob URLs.\n * For the user defined contents referenced in the H5P content/content.json\n * we shim the H5P.getPath method to do a lookup into our own\n * internal file lookup so we can return the Blob URLs.\n * We also shim the H5P ContentType class to override the getLibraryFilePath\n * which allows us to return our blob URLs for files inside the content widget library folders.\n * Lastly, the getLibraryPath method of the H5P object is overridden to return\n * a reference to the zipcontent endpoint, to allow files to be dynamically loaded\n * as a fallback.\n */\nexport default class H5PRunner {\n  constructor(shim) {\n    this.shim = shim;\n    this.data = shim.data;\n    this.scriptLoader = this.scriptLoader.bind(this);\n  }\n\n  init(iframe, filepath, loaded, errored) {\n    // An array of the H5P package dependencies for this library\n    // This is not a sorted list, but the result of recursing through\n    this.dependencies = [];\n    // For each H5P package an array of the Javascript files needed\n    this.jsDependencies = {};\n    // For each H5P package an array of the CSS files needed\n    this.cssDependencies = {};\n    // For each H5P package, an object that maps the original file\n    // reference in the H5P file to a blob URL reference, except for\n    // CSS files which will contain the raw string contents\n    // of the file so we can do some extra processing on them\n    this.packageFiles = {};\n    // An object that maps from a path in the `content` folder of the\n    // H5P package to a blob URL reference for that content item\n    // we can then use this to return blob URLs when H5P packages request\n    // specific content - without having to do a bunch of extra rewriting of\n    // URLs.\n    this.contentPaths = {};\n    // The JSON representation of `content/content.json` in the H5P file\n    // this is a deeply nested JSON object that contains path references\n    // for all the non-package creator added content that is part of this\n    // H5P file. We could in theory have done URL replacement in this, but\n    // monkey patching the H5P APIs that do this seemed safer.\n    this.contentJson = '';\n    // The entry point package for this H5P file - the 'top level' library.\n    this.library = null;\n    // Maps of JS paths and CSS paths to quickly check if a JS or CSS file is loaded\n    // we could store this as an array, but this lets us potentially monkey\n    // patch H5P in the future for more efficient look ups.\n    this.loadedJs = {};\n    this.loadedCss = {};\n    // The iframe that we should be loading H5P in - this is probably not the\n    // same as the current window context that the H5P constructor has been\n    // invoked in.\n    this.iframe = iframe;\n    // Relative URL to H5P - ideal to keep this simple by convention\n    // this will avoid having to pass in extra initialization info into\n    // hashi.\n    this.iframe.src = `../h5p/${H5PFilename}`;\n    // This is the path to the H5P file which we load in its entirety.\n    this.filepath = filepath;\n    // A fallback URL to the zipcontent endpoint for this H5P file\n    this.zipcontentUrl = new URL(\n      `../../zipcontent/${this.filepath.substring(this.filepath.lastIndexOf('/') + 1)}`,\n      window.location\n    ).href;\n    // Callback to call when H5P has finished loading\n    this.loaded = loaded;\n    // Callback to call when H5P errors\n    this.errored = errored;\n    // Set this to a dummy value - we use this for generating the H5P ids,\n    // and for logging xAPI statements about the content.\n    this.contentNamespace = CONTENT_ID;\n    const start = performance.now();\n    // First load the full H5P file as binary so we can read it using JSZip\n    loadBinary(this.filepath)\n      .then(file => {\n        // Store the zip locally for later reference\n        this.zip = new Zip(file);\n        // Recurse all the package dependencies\n        return this.recurseDependencies('h5p.json', true);\n      })\n      .then(() => {\n        // Once we have found all the dependencies, we call this\n        // to sort the dependencies by their dependencies to make an\n        // ordered list, with every package being loaded only once its\n        // dependencies have been loaded.\n        this.setDependencies();\n        return this.processFiles().then(() => {\n          console.debug(`H5P file processed in ${performance.now() - start} ms`);\n          this.metadata = pick(this.rootConfig, metadataKeys);\n          // Do any URL substitition on CSS dependencies\n          // and turn them into Blob URLs.\n          // Also order the dendencies according to our sorted\n          // dependency tree.\n          this.processCssDependencies();\n          this.processJsDependencies();\n          // If the iframe has already loaded, start H5P\n          // Sometimes this check can catch the iframe before it has started\n          // to load H5P, when it is still blank, but loaded.\n          // So we also check that H5P is defined on the contentWindow to be sure\n          // that the ready state applies to the loading of the H5P html file.\n          if (\n            this.iframe.contentDocument &&\n            this.iframe.contentDocument.readyState === 'complete' &&\n            this.iframe.contentWindow.H5P\n          ) {\n            return this.initH5P();\n          }\n          // Otherwise wait for the load event.\n          this.iframe.addEventListener('load', () => this.initH5P());\n        });\n      });\n  }\n\n  stateUpdated() {\n    this.shim.stateUpdated();\n  }\n\n  /*\n   * Shim H5P, load dependencies, and then start H5P in the contentWindow.\n   */\n  initH5P() {\n    this.shimH5P(this.iframe.contentWindow);\n    return this.scriptLoader(this.cssURL, true).then(() => {\n      return this.scriptLoader(this.javascriptURL).then(() => {\n        try {\n          // Start H5P\n          // In spite of our best effors, we can't guarantee that the H5P\n          // library will run properly - at least one of the libraries\n          // e.g. Find The Words, is not compatible with IE11, and so causes\n          // errors when attempting to render.\n          // We catch the error and report it to the user to avoid confusion and\n          // allow the to report to us.\n          this.iframe.contentWindow.H5P.init();\n          this.loaded();\n          setTimeout(() => {\n            for (let instance of this.iframe.contentWindow.H5P.instances) {\n              this.iframe.contentWindow.H5P.trigger(instance, 'resize');\n            }\n          }, 0);\n        } catch (e) {\n          this.errored(e);\n        }\n      });\n    });\n  }\n\n  /*\n   * Monkey patch the main H5P object to make it behave in a way that works for us\n   * By the time this is called, H5P should already be instantiated in the iframe window.\n   */\n  shimH5P(contentWindow) {\n    // First setup a div for our content, for H5P to pick up and populate.\n    const div = contentWindow.document.createElement('div');\n    div.classList.add('h5p-content');\n    div.setAttribute('data-content-id', this.contentNamespace);\n    contentWindow.document.body.appendChild(div);\n    // Set up the `getPath` method so that we can resolve any paths\n    // with our mapped contentPaths object which will map content files\n    // from the H5P file to the blob URLs we have created for them.\n    const H5P = contentWindow.H5P;\n    const originalGetPath = H5P.getPath;\n    const self = this;\n    H5P.getPath = function(path, contentId) {\n      // Handle files that have a #tmp suffix\n      // these are meant to only be used during editing,\n      // but it seems possible for these to be exported by H5P editors\n      if (path.substr(-4, 4) === '#tmp') {\n        path = path.substr(0, path.length - 4);\n      }\n      if (self.contentPaths[path]) {\n        return self.contentPaths[path];\n      }\n      return originalGetPath(path, contentId);\n    };\n    H5P.getContentPath = function() {\n      return self.zipcontentUrl + '/content';\n    };\n    // Shim the user data handling functions so that we return data from our\n    // internal data storage for the H5P component.\n    H5P.getUserData = function(contentId, dataId, done, subContentId = 0) {\n      const data = get(self.data, [subContentId, dataId]);\n      if (data === 'RESET') {\n        return done(undefined, null);\n      }\n      return done(undefined, data);\n    };\n    // Store data from H5P into our own internal data storage\n    H5P.setUserData = function(\n      contentId,\n      dataId,\n      data,\n      { subContentId = 0, errorCallback = null } = {}\n    ) {\n      try {\n        data = JSON.stringify(data);\n      } catch (err) {\n        if (isFunction(errorCallback)) {\n          errorCallback(err);\n        }\n        return; // Failed to serialize.\n      }\n      set(self.data, [subContentId, dataId], data);\n      self.stateUpdated();\n    };\n    // Delete data from H5P in our internal data storage.\n    H5P.deleteUserData = function(contentId, dataId, subContentId = 0) {\n      unset(self.data, [subContentId, dataId]);\n      self.stateUpdated();\n    };\n    // Monkey patch the H5P ContentType constructor factory\n    // This function is not a constructor, but rather a factory\n    // that makes constructor functions.\n    // Here we call the original, and then update the prototype\n    // of the produced constructor to allow us to manipulate\n    // the `getLibraryFilePath` function.\n    // In most cases, this should already have been substituted\n    // for our blob URLs - if not, this needs to be updated to do\n    // a lookup inside our currently parsed packages for the URL.\n    const originalContentType = H5P.ContentType;\n    H5P.ContentType = function(isRoot) {\n      const ct = originalContentType(isRoot);\n      ct.prototype.getLibraryFilePath = function(filePath) {\n        const url = self.packageFiles[this.libraryInfo.versionedNameNoSpaces + '/'][filePath];\n        // Some H5P libraries use this with a blank filePath argument to get a file path they can\n        // append to for retrieving files - which is monumentally stupid, but what can you do?\n        // In this case, the URL will be undefined, so we should return the URL path for the\n        // zipcontent endpoint so they can get their files.\n        if (url) {\n          return url;\n        }\n        // Build the URL path to access files inside this specific library\n        return self.zipcontentUrl + '/' + this.libraryInfo.versionedNameNoSpaces + '/';\n      };\n      return ct;\n    };\n    // Monkey patch setActor to allow us to inject our own\n    // XAPI actor definition\n    H5P.XAPIEvent.prototype.setActor = function() {\n      if (contentWindow.xAPI) {\n        contentWindow.xAPI.prepareStatement(this.data.statement);\n      }\n    };\n    const debouncedHandlers = {};\n    for (let debouncedVerb of debounceVerbs) {\n      const verb = XAPIVerbMap[debouncedVerb];\n      debouncedHandlers[verb] = debounce(\n        function(statement) {\n          contentWindow.xAPI.sendStatement(statement, true).catch(err => {\n            console.error('Statement: ', statement, 'gave the following error: ', err);\n          });\n        },\n        debounceDelay * 1000,\n        // Invoke on the leading as well as the trailing edge\n        // so that we alert immediately on an event.\n        { leading: true, maxWait: maxDelay * 1000 }\n      );\n    }\n    // Add event listener to allow us to capture xAPI events\n    H5P.externalDispatcher.on('xAPI', function(event) {\n      if (contentWindow.xAPI) {\n        const statement = event.data.statement;\n        if (\n          statement.object &&\n          statement.object.id.startsWith(self.H5PContentIdentifier) &&\n          statement.object.id !== self.H5PContentIdentifier &&\n          statement.verb &&\n          completionVerbMap[statement.verb.id]\n        ) {\n          // Catch any statements that might imply completion but are actually only for subcontent.\n          // H5P sends these events for subcontents, even though it is against the CMI5 spec.\n          // Swap them out for the progressed verb to indicate progression without completion.\n          statement.verb.id = XAPIVerbMap.progressed;\n        }\n        if (doNotLogVerbMap[statement.verb.id]) {\n          return;\n        } else if (debouncedHandlers[statement.verb.id]) {\n          debouncedHandlers[statement.verb.id](statement);\n        } else {\n          contentWindow.xAPI.sendStatement(event.data.statement, true).catch(err => {\n            console.error('Statement: ', statement, 'gave the following error: ', err);\n          });\n        }\n      }\n    });\n  }\n\n  get H5PContentIdentifier() {\n    return (\n      (this.rootConfig && this.rootConfig.source) ||\n      `http://kolibri.to/content/${this.contentNamespace}`\n    );\n  }\n\n  /*\n   * This will setup the H5PIntegration property that H5P then uses\n   * to configure itself.\n   */\n  shimH5PIntegration(contentWindow) {\n    const self = this;\n    this.integrationShim = {\n      get contents() {\n        return {\n          [contentIdentifier(self.contentNamespace)]: {\n            library: self.library,\n            jsonContent: self.contentJson,\n            fullScreen: false,\n            displayOptions: {\n              copyright: false,\n              download: false,\n              embed: false,\n              export: false,\n              frame: false,\n              icon: false,\n            },\n            contentUserData: self.data,\n            exportUrl: '',\n            embedCode: '',\n            resizeCode: '',\n            mainId: self.contentNamespace,\n            url: self.H5PContentIdentifier,\n            title: self.rootConfig.title,\n            styles: Object.keys(self.loadedCss),\n            scripts: Object.keys(self.loadedJs),\n            metadata: self.metadata,\n          },\n        };\n      },\n      l10n: {\n        H5P: {},\n      },\n      get loadedJs() {\n        return Object.keys(self.loadedJs);\n      },\n      get loadedCss() {\n        return Object.keys(self.loadedCss);\n      },\n      get user() {\n        return {\n          name: self.userData.userFullName,\n          mail: '',\n        };\n      },\n      // Set this library path so that we can return the zipcontent\n      // endpoint URL for this H5P file, so that it just looks up\n      // libraries inside the current H5P.\n      get urlLibraries() {\n        return self.zipcontentUrl;\n      },\n    };\n    Object.defineProperty(contentWindow, 'H5PIntegration', {\n      value: this.integrationShim,\n      configurable: true,\n    });\n  }\n\n  /**\n   * Loads a Javascript file and executes it.\n   * @param  {String} url URL for the script\n   * @return {Promise}     Promise that resolves when the script has loaded\n   */\n  scriptLoader(url, css = false) {\n    const iframeDocument = this.iframe.contentWindow.document;\n    return new Promise((resolve, reject) => {\n      let script;\n      if (!css) {\n        script = iframeDocument.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        script.async = true;\n        script.addEventListener('load', () => resolve(script));\n        script.addEventListener('error', reject);\n      } else {\n        script = iframeDocument.createElement('link');\n        script.rel = 'stylesheet';\n        script.type = 'text/css';\n        script.href = url;\n        // Can't detect loading for css, so just assume it worked.\n        resolve(script);\n      }\n      iframeDocument.body.appendChild(script);\n    });\n  }\n\n  /*\n   * Use the Toposort library to sort all our dependencies into an order\n   * that will resolve interdependencies as well as possible.\n   */\n  setDependencies() {\n    const dependencySorter = new Toposort();\n\n    for (let dependency of this.dependencies) {\n      this.packageFiles[dependency.packagePath] = {};\n      dependencySorter.add(dependency.packagePath, dependency.dependencies);\n\n      this.cssDependencies[dependency.packagePath] = dependency.preloadedCss;\n\n      this.jsDependencies[dependency.packagePath] = dependency.preloadedJs;\n    }\n\n    this.sortedDependencies = dependencySorter.sort().reverse();\n  }\n\n  /*\n   * A function to recurse through all dependencies listed in a library or package\n   * definition. For the root library definition, this also sets the global rootConfig\n   * JSON that defines some global details about this H5P file.\n   * visitedPaths allow us to quickly check that we haven't already recursed this dependency\n   * which will stop us from getting into a circular dependency hell.\n   */\n  recurseDependencies(jsonFile, root, visitedPaths = {}, packagePath = '') {\n    return this.zip.file(jsonFile).then(file => {\n      if (!file) {\n        return;\n      }\n      const json = JSON.parse(strFromU8(file.obj));\n      const preloadedDependencies = json['preloadedDependencies'] || [];\n      // Make a copy so that we are not modifying the same object\n      visitedPaths = {\n        ...visitedPaths,\n      };\n      // If root, then this JSON is the rootConfig.\n      if (root) {\n        this.rootConfig = json;\n      }\n      return Promise.all(\n        preloadedDependencies.map(dep => {\n          const depPackagePath = `${dep.machineName}-${dep.majorVersion}.${dep.minorVersion}/`;\n          // If root, then this is the root config, and so this descriptor is the main library\n          // descriptor for this H5P file.\n          if (root && !this.library && dep.machineName === json.mainLibrary) {\n            this.library = `${dep.machineName} ${dep.majorVersion}.${dep.minorVersion}`;\n          }\n          if (visitedPaths[depPackagePath]) {\n            // If we have visited this dependency before\n            // then we are in a cyclic dependency graph\n            // so stop!\n            return Promise.resolve(depPackagePath);\n          }\n          // Add this to our visited paths so that future recursive calls know a cyclic\n          // dependency when they see one!\n          visitedPaths[depPackagePath] = true;\n          // Now recurse the dependencies of each of the dependencies!\n          return this.recurseDependencies(\n            depPackagePath + 'library.json',\n            false,\n            visitedPaths,\n            depPackagePath\n          ).then(() => depPackagePath);\n        })\n      ).then(dependencies => {\n        if (packagePath) {\n          // If this specification is a package (i.e. not the root)\n          // then get all of the preloadedJs and preloadedCss that this\n          // package needs and summarize it in an object in our dependencies\n          // list.\n          const preloadedJs = (json['preloadedJs'] || []).map(js => js.path);\n          const preloadedCss = (json['preloadedCss'] || []).map(css => css.path);\n          this.dependencies.push({\n            packagePath,\n            dependencies,\n            preloadedCss,\n            preloadedJs,\n          });\n        }\n      });\n    });\n  }\n\n  /*\n   * We process JS dependencies after we've done preprocessing of\n   * our other files, to set our jsDependencies according to our sorted\n   * dependency order.\n   */\n  processJsDependencies() {\n    const concatenatedJS = this.sortedDependencies.reduce((wholeJS, dependency) => {\n      return (this.jsDependencies[dependency] || []).reduce((allJs, jsDep) => {\n        return `${allJs}${this.packageFiles[dependency][jsDep]}\\n\\n`;\n      }, wholeJS);\n    }, '');\n    this.javascriptURL = URL.createObjectURL(\n      new Blob([concatenatedJS], { type: 'text/javascript' })\n    );\n  }\n\n  /*\n   * We process CSS dependencies after we've done preprocessing of\n   * our other files, to make sure we have already created blob URLs for them\n   * and then substitute those referenced paths for the blob URLs\n   */\n  processCssDependencies() {\n    const concatenatedCSS = this.sortedDependencies.reduce((wholeCSS, dependency) => {\n      return (this.cssDependencies[dependency] || []).reduce((allCss, cssDep) => {\n        const css = replacePaths(cssDep, this.packageFiles[dependency]);\n        // We have completed the path substition, so concatenate the CSS.\n        return `${allCss}${css}\\n\\n`;\n      }, wholeCSS);\n    }, '');\n    this.cssURL = URL.createObjectURL(new Blob([concatenatedCSS], { type: 'text/css' }));\n  }\n\n  /*\n   * Process files in the content folder and store a reference\n   * from their path without `content/` prefixed to the blob URL we\n   * are creating for them.\n   */\n  processContent(file) {\n    const fileName = file.name.replace('content/', '');\n    if (fileName === 'content.json') {\n      // Store this special file contents here as raw text\n      // as that is how H5P expects it.\n      this.contentJson = strFromU8(file.obj);\n    } else {\n      // Create blob urls for every item in the content folder\n      this.contentPaths[fileName] = createBlobUrl(file.obj, fileName);\n    }\n  }\n\n  /*\n   * Do extraction and processing of a specific file in a package\n   */\n  processPackageFile(file, packagePath) {\n    const fileName = file.name.replace(packagePath, '');\n    // Do special processing of js and css files for this package\n    // For both, track the file names to generate `loadedJS` and `loadedCSS`\n    // for H5P.\n    const jsFile = this.jsDependencies[packagePath].indexOf(fileName) > -1;\n    const cssFile = this.cssDependencies[packagePath].indexOf(fileName) > -1;\n    if (cssFile || jsFile) {\n      // For CSS, this allows us to do URL replacement. Possible we could do this for\n      // JS files as well, but the H5P PHP implementation does not do anything for them.\n      // Flag in our appropriate maps that these files will be preloaded.\n      // For both we will concatenate all the assets before turning into a blob\n      // URL, because some H5P packages depend on setTimeout delays to call dependencies that\n      // load after them in the same package - using chained script loading, this breaks,\n      // because the Promise allows the main thread to be released, and the setTimeout to jump in.\n      if (jsFile) {\n        this.loadedJs[file.name] = true;\n      } else {\n        this.loadedCss[file.name] = true;\n      }\n      // If it's a CSS file load as a string from the zipfile for later\n      // replacement of URLs.\n      // For JS or CSS, we load as string to concatenate and later turn into a single file.\n      this.packageFiles[packagePath][fileName] = strFromU8(file.obj);\n    } else {\n      // Otherwise just create a blob URL for this file and store it in our packageFiles maps.\n      this.packageFiles[packagePath][fileName] = createBlobUrl(file.obj, fileName);\n    }\n  }\n\n  /*\n   * Process all files in the zip, content files and files in the packages\n   */\n  processFiles() {\n    return Promise.all([\n      this.zip.files('content/').then(contentFiles => {\n        contentFiles.map(file => this.processContent(file));\n      }),\n      ...Object.keys(this.packageFiles).map(packagePath => {\n        // JSZip uses regex for path matching, so we first do regex escaping on the packagePath\n        // in order to get an exact match, and not accidentally do a regex match based on the path\n        return this.zip.files(packagePath).then(packageFiles => {\n          packageFiles.map(file => this.processPackageFile(file, packagePath));\n        });\n      }),\n    ]);\n  }\n}\n","/*\n * Vendored from https://github.com/Stuk/jszip-utils/blob/master/lib/index.js\n */\n\n/**\n * @param  {string} path    The path to the resource to GET.\n * @return {Promise}\n */\nexport default function(path) {\n  return new Promise((resolve, reject) => {\n    try {\n      const xhr = new window.XMLHttpRequest();\n\n      xhr.open('GET', path, true);\n\n      xhr.responseType = 'arraybuffer';\n\n      xhr.onreadystatechange = function() {\n        // use `xhr` and not `this`... thanks IE\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200 || xhr.status === 0) {\n            try {\n              resolve(new Uint8Array(xhr.response));\n            } catch (err) {\n              reject(new Error(err));\n            }\n          } else {\n            reject(new Error('Ajax error for ' + path + ' : ' + xhr.status + ' ' + xhr.statusText));\n          }\n        }\n      };\n      xhr.send();\n    } catch (e) {\n      reject(new Error(e), null);\n    }\n  });\n}\n"],"sourceRoot":""}