# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['fastapi_htmx']

package_data = \
{'': ['*']}

install_requires = \
['fastapi>=0.94,<0.95', 'jinja2>=3.1,<4.0']

setup_kwargs = {
    'name': 'fastapi-htmx',
    'version': '0.1.0',
    'description': 'Extension for FastAPI to make HTMX easier to use.',
    'long_description': '# FastAPI-HTMX\n\nExtension for FastAPI to make HTMX easier to use.\n\nFastAPI-HTMX is implemented as a decorator, so it can be used selectively on routes in you FastAPI project. Furthermore it reduces boilerplate and allows for rapid prototyping by providing convenient helpers.\n\n## Install\n\ninstall via `pip`:\n```\n$ pip install fastapi-htmx\n```\n\ninstall via `poetry`:\n```\n$ poetry add fastapi-htmx\n```\n\n## Usage\n\n### Getting Started\n\nBasic example using FastAPI with `fastapi-htmx`\n\n`my_app/api.py`:\n```python\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi_htmx import htmx, htmx_init\n\napp = FastAPI()\nhtmx_init(templates=Jinja2Templates(directory=Path("my_app") / "templates"))\n\n@app.get("/", response_class=HTMLResponse)\n@htmx("index", "index")\nasync def root_page(request: Request):\n    return {"greeting": "Hello World"}\n\n@app.get("/customers", response_class=HTMLResponse)\n@htmx("customers")\nasync def get_customers(request: Request):\n    return {"customers": ["John Doe", "Jane Doe"]}\n```\n\nNote that:\n- `htmx()` got a parameter, which is the Jinja2 template to use\n- `htmx_init()` is needed for FastAPI-HTMX to find the templates and more\n- **There is no direct usage of a template, instead the template is specified and the needed variables are passed on by returning them**. Similar to a standard REST endpoint.\n    - This simplifies switching between templates and REST endpoints. See the "Usage" section for further examples.\n- **`request: Request` although not used, it is currently required for the decorator to work!**\n\nThe above example also needs these very basic [Jinja2 templates](https://jinja.palletsprojects.com/en/3.1.x/templates/) in `my_app/templates/` to work.\n\nThe root page `my_app/templates/index.jinja2`:\n```jinja2\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello FastAPI-HTMX</title>\n</head>\n<body>\n    <h1>{{ greeting }}</h1>\n    <button\n        hx-get="/customers"\n        hx-swap="innerHTML"\n        hx-target="#customers_list"\n    >\n        Load Data\n    </button>\n    <div id="customers_list"></div>\n    <script src="https://unpkg.com/htmx.org@1.8.6"></script>\n</body>\n</html>\n```\n\nThe [partial template to load with htmx](https://htmx.org/docs/#introduction) `my_app/templates/customers.jinja2`:\n```jinja2\n<ul>\n    {% for customer in customers %}\n        <li>{{ customer }}</li>\n    {% endfor %}\n</ul>\n```\n\n### Main Concept\n\nThe decorator `htmx` provides the following helpers:\n\n- `partial_template_name` The partial template to use\n- `full_template_name` The full page template to use when URL rewriting + history is used\n- `*_template_constructor` For DRY code, in case the logic to gather all needed variables is needed multiple times\n\nSeeing these arguments one might ask themselves: Why use a full template or functions to provide the variables for the templates if there is an endpoint anyway?\n\nThe idea behind FastAPI-HTMX is to maintain a modular structure in the app and with the endpoints. Similar to a REST API with a [SPA](https://developer.mozilla.org/en-US/docs/Glossary/SPA). This way the frontend can be modular as well. This majorly helps with supporting [URL rewriting and the history](https://htmx.org/docs/#history) in the frontend. A simple endpoint just answers with the partial. If the URL is rewritten and a user navigates back, reloads the page or copies the URL and opens it in another tab or shares it, only the partial would be shown in the browser. **To enable this SPA like functionality FastAPI-HTMX provides these arguments for the decorator and requires to return a dict of the needed variables**. In order to support this in an app, see the following example:\n\n`my_app/api_with_constructors.py`:\n```python\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, Request\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom fastapi_htmx import htmx, htmx_init\n\napp = FastAPI()\nhtmx_init(templates=Jinja2Templates(directory=Path("my_app") / "templates"))\n\ndef construct_customers():\n    return {"customers": ["John Doe", "Jane Doe"]}\n\ndef construct_root_page():\n    return {\n        "greeting": "Hello World",\n        **construct_customers()\n    }\n\n@app.get("/", response_class=HTMLResponse)\n@htmx("index", "index")\nasync def root_page(request: Request):\n    return construct_root_page()\n\n@app.get("/customers", response_class=HTMLResponse)\n@htmx("customers", "index", construct_customers, construct_root_page)\nasync def get_customers(request: Request):\n    pass\n```\n\nNote that:\n- The `construct_*` functions where added, they now return the data\n    - **`construct_root_page` gathers all variables specified needed for the root page, including partials**\n        - **This also means you must avoid naming conflicts across endpoints.**\n        - Costly operations can still be ignored, just use if statements in the template or similar\n- The decorators arguments where extended\n    - The second argument is the template to use when the rewritten URL is used directly (new tab, navigation or reload)\n        - **Since `construct_root_page` gathers all the data for the whole page, the whole page can be returned to the client**\n    - The other arguments are just to save some boilerplate code handling the [`HX-Request` header](https://htmx.org/attributes/hx-push-url/)\n        - **There is no need to use these arguments of the decorator, they are just for convenience.** If needed the endpoint can be used for the logic as well. Especially if no URL rewriting is needed.\n\nFor the above code to work the `my_app/templates/index.jinja2` needs to be changed as well. The changes are in the button and target div.\nChanged root page `my_app/templates/index.jinja2`:\n```jinja2\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Hello FastAPI-HTMX</title>\n</head>\n<body>\n    <h1>{{ greeting }}</h1>\n    <button\n        hx-get="/customers"\n        hx-push-url="true"\n        hx-swap="innerHTML"\n        hx-target="#customers_list"\n    >\n        Load Data\n    </button>\n    <div id="customers_list">\n        {% include \'customers.jinja2\' %}\n    </div>\n    <script src="https://unpkg.com/htmx.org@1.8.6"></script>\n</body>\n</html>\n```\n\nNote that:\n- `hx-push-url="true"` was added to the button\n- The partial is now loaded by default requiring the main endpoint to also provide the needed variables like shown above\n\nThe unchanged partial `my_app/templates/customers.jinja2`:\n```jinja2\n<ul>\n    {% for customer in customers %}\n        <li>{{ customer }}</li>\n    {% endfor %}\n</ul>\n```\n\nAdditional partials and their endpoints can be added by the same logic:\n- Include the partial in the parent Jinja2 template, like the main template. A hierarchy is possible as well.\n- Refactor the partials endpoints logic into a function\n    - Add it\'s return vale to the parents constructor function like above\n    - Add the parents template and constructor function to the partials endpoints htmx decorator arguments\n\n### Advanced Usage\n\nAdd [custom filters](https://jinja.palletsprojects.com/en/3.1.x/api/#custom-filters) to Jinja2 templates:\n```python\n# ...\ndef datetime_format(value: datetime, format="%H:%M %d.%m.%Y"):\n    return value.strftime(format) if value is not None else ""\n\ntemplates = Jinja2Templates(directory=Path("my_app") / "templates")\ntemplates.env.filters["datetime_format"] = datetime_format\nhtmx_init(templates=templates)\n# ...\n```\n',
    'author': 'maces',
    'author_email': 'fastapi-htmx@mzip.de',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'https://github.com/maces/fastapi-htmx',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.10,<4.0',
}


setup(**setup_kwargs)
