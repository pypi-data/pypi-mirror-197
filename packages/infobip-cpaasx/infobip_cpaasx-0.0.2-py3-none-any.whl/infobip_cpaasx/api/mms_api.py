# coding: utf-8

"""
    This class is auto generated from the Infobip OpenAPI specification
    through the OpenAPI Specification Client API libraries (Re)Generator (OSCAR),
    powered by the OpenAPI Generator (https://openapi-generator.tech).
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError, StrictBytes
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr

from typing import Optional

from infobip_cpaasx.models.mms_advanced_request import MmsAdvancedRequest
from infobip_cpaasx.models.mms_inbound_report_response import MmsInboundReportResponse
from infobip_cpaasx.models.mms_report_response import MmsReportResponse
from infobip_cpaasx.models.mms_send_result import MmsSendResult
from infobip_cpaasx.models.mms_upload_binary_result import MmsUploadBinaryResult

from infobip_cpaasx.api_client import ApiClient
from infobip_cpaasx.exceptions import ApiTypeError, ApiValueError  # noqa: F401


class MmsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def get_inbound_mms_messages(
        self,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of delivery reports that will be returned."
            ),
        ] = None,
        **kwargs
    ) -> MmsInboundReportResponse:  # noqa: E501
        """Get inbound MMS messages  # noqa: E501

        If for some reason you are unable to receive incoming MMS at the endpoint of your choice in real time, you can use this API call to fetch messages. Each request will return a batch of received messages - only once. The following API request will return only new messages that arrived since the last API request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_inbound_mms_messages(limit, async_req=True)
        >>> result = thread.get()

        :param limit: Maximum number of delivery reports that will be returned.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MmsInboundReportResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.get_inbound_mms_messages_with_http_info(
            limit, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_inbound_mms_messages_with_http_info(
        self,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of delivery reports that will be returned."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get inbound MMS messages  # noqa: E501

        If for some reason you are unable to receive incoming MMS at the endpoint of your choice in real time, you can use this API call to fetch messages. Each request will return a batch of received messages - only once. The following API request will return only new messages that arrived since the last API request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_inbound_mms_messages_with_http_info(limit, async_req=True)
        >>> result = thread.get()

        :param limit: Maximum number of delivery reports that will be returned.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MmsInboundReportResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["limit"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inbound_mms_messages" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "MmsInboundReportResponse",
        }

        return self.api_client.call_api(
            "/mms/1/inbox/reports",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_outbound_mms_message_delivery_reports(
        self,
        bulk_id: Annotated[
            Optional[StrictStr],
            Field(description="ID of bulk for which a delivery report is requested."),
        ] = None,
        message_id: Annotated[
            Optional[StrictStr],
            Field(description="ID of MMS for which a delivery report is requested."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of delivery reports that will be returned."
            ),
        ] = None,
        **kwargs
    ) -> MmsReportResponse:  # noqa: E501
        """Get outbound MMS message delivery reports  # noqa: E501

        If you are unable to receive real-time delivery reports towards your endpoint for various reasons, we offer you an API method to fetch batches of delivery reports to confirm whether specific messages have been delivered. Each request towards this endpoint will return batches of the latest delivery reports. Please note they will be returned only once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_outbound_mms_message_delivery_reports(bulk_id, message_id, limit, async_req=True)
        >>> result = thread.get()

        :param bulk_id: ID of bulk for which a delivery report is requested.
        :type bulk_id: str
        :param message_id: ID of MMS for which a delivery report is requested.
        :type message_id: str
        :param limit: Maximum number of delivery reports that will be returned.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MmsReportResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.get_outbound_mms_message_delivery_reports_with_http_info(
            bulk_id, message_id, limit, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_outbound_mms_message_delivery_reports_with_http_info(
        self,
        bulk_id: Annotated[
            Optional[StrictStr],
            Field(description="ID of bulk for which a delivery report is requested."),
        ] = None,
        message_id: Annotated[
            Optional[StrictStr],
            Field(description="ID of MMS for which a delivery report is requested."),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of delivery reports that will be returned."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get outbound MMS message delivery reports  # noqa: E501

        If you are unable to receive real-time delivery reports towards your endpoint for various reasons, we offer you an API method to fetch batches of delivery reports to confirm whether specific messages have been delivered. Each request towards this endpoint will return batches of the latest delivery reports. Please note they will be returned only once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_outbound_mms_message_delivery_reports_with_http_info(bulk_id, message_id, limit, async_req=True)
        >>> result = thread.get()

        :param bulk_id: ID of bulk for which a delivery report is requested.
        :type bulk_id: str
        :param message_id: ID of MMS for which a delivery report is requested.
        :type message_id: str
        :param limit: Maximum number of delivery reports that will be returned.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MmsReportResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["bulk_id", "message_id", "limit"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_outbound_mms_message_delivery_reports" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("bulk_id") is not None:  # noqa: E501
            _query_params.append(("bulkId", _params["bulk_id"]))
        if _params.get("message_id") is not None:  # noqa: E501
            _query_params.append(("messageId", _params["message_id"]))
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "MmsReportResponse",
        }

        return self.api_client.call_api(
            "/mms/1/reports",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def send_mms_message(
        self, mms_advanced_request: MmsAdvancedRequest, **kwargs
    ) -> MmsSendResult:  # noqa: E501
        """Send MMS message  # noqa: E501

        This method allows you to send one MMS or bulk MMS to a recipient or multiple recipients in one request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_mms_message(mms_advanced_request, async_req=True)
        >>> result = thread.get()

        :param mms_advanced_request: (required)
        :type mms_advanced_request: MmsAdvancedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MmsSendResult
        """
        kwargs["_return_http_data_only"] = True
        return self.send_mms_message_with_http_info(
            mms_advanced_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def send_mms_message_with_http_info(
        self, mms_advanced_request: MmsAdvancedRequest, **kwargs
    ):  # noqa: E501
        """Send MMS message  # noqa: E501

        This method allows you to send one MMS or bulk MMS to a recipient or multiple recipients in one request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_mms_message_with_http_info(mms_advanced_request, async_req=True)
        >>> result = thread.get()

        :param mms_advanced_request: (required)
        :type mms_advanced_request: MmsAdvancedRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MmsSendResult, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["mms_advanced_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_mms_message" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["mms_advanced_request"]:
            _body_params = _params["mms_advanced_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "MmsSendResult",
        }

        return self.api_client.call_api(
            "/mms/1/advanced",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def upload_binary(
        self,
        x_content_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="ContentId that uniquely identifies the binary content.",
            ),
        ],
        x_media_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="Content mime type. Should be populated by standard MIME types (IANA media types).",
            ),
        ],
        body: StrictBytes,
        x_validity_period_minutes: Annotated[
            Optional[StrictInt],
            Field(
                description="Validity period in minutes after which the content will be deleted. (default: 69120 minutes)."
            ),
        ] = None,
        **kwargs
    ) -> MmsUploadBinaryResult:  # noqa: E501
        """Upload binary content  # noqa: E501

        This method allows you to upload binary content that you can reference when sending MMS messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_binary(x_content_id, x_media_type, body, x_validity_period_minutes, async_req=True)
        >>> result = thread.get()

        :param x_content_id: ContentId that uniquely identifies the binary content. (required)
        :type x_content_id: str
        :param x_media_type: Content mime type. Should be populated by standard MIME types (IANA media types). (required)
        :type x_media_type: str
        :param body: (required)
        :type body: str
        :param x_validity_period_minutes: Validity period in minutes after which the content will be deleted. (default: 69120 minutes).
        :type x_validity_period_minutes: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: MmsUploadBinaryResult
        """
        kwargs["_return_http_data_only"] = True
        return self.upload_binary_with_http_info(
            x_content_id, x_media_type, body, x_validity_period_minutes, **kwargs
        )  # noqa: E501

    @validate_arguments
    def upload_binary_with_http_info(
        self,
        x_content_id: Annotated[
            StrictStr,
            Field(
                ...,
                description="ContentId that uniquely identifies the binary content.",
            ),
        ],
        x_media_type: Annotated[
            StrictStr,
            Field(
                ...,
                description="Content mime type. Should be populated by standard MIME types (IANA media types).",
            ),
        ],
        body: StrictBytes,
        x_validity_period_minutes: Annotated[
            Optional[StrictInt],
            Field(
                description="Validity period in minutes after which the content will be deleted. (default: 69120 minutes)."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Upload binary content  # noqa: E501

        This method allows you to upload binary content that you can reference when sending MMS messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_binary_with_http_info(x_content_id, x_media_type, body, x_validity_period_minutes, async_req=True)
        >>> result = thread.get()

        :param x_content_id: ContentId that uniquely identifies the binary content. (required)
        :type x_content_id: str
        :param x_media_type: Content mime type. Should be populated by standard MIME types (IANA media types). (required)
        :type x_media_type: str
        :param body: (required)
        :type body: str
        :param x_validity_period_minutes: Validity period in minutes after which the content will be deleted. (default: 69120 minutes).
        :type x_validity_period_minutes: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(MmsUploadBinaryResult, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "x_content_id",
            "x_media_type",
            "body",
            "x_validity_period_minutes",
        ]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_binary" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))
        if _params["x_content_id"]:
            _header_params["X-Content-Id"] = _params["x_content_id"]
        if _params["x_media_type"]:
            _header_params["X-Media-Type"] = _params["x_media_type"]
        if _params["x_validity_period_minutes"]:
            _header_params["X-Validity-Period-Minutes"] = _params[
                "x_validity_period_minutes"
            ]

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["body"]:
            _body_params = _params["body"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/octet-stream"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "MmsUploadBinaryResult",
        }

        return self.api_client.call_api(
            "/mms/1/content",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
