# coding: utf-8

"""
    This class is auto generated from the Infobip OpenAPI specification
    through the OpenAPI Specification Client API libraries (Re)Generator (OSCAR),
    powered by the OpenAPI Generator (https://openapi-generator.tech).
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr

from typing import List, Optional

from infobip_cpaasx.models.number_registration_brand import NumberRegistrationBrand
from infobip_cpaasx.models.number_registration_brand_status import (
    NumberRegistrationBrandStatus,
)
from infobip_cpaasx.models.number_registration_brand_vet import (
    NumberRegistrationBrandVet,
)
from infobip_cpaasx.models.number_registration_campaign import (
    NumberRegistrationCampaign,
)
from infobip_cpaasx.models.number_registration_network_status import (
    NumberRegistrationNetworkStatus,
)
from infobip_cpaasx.models.number_registration_page_response_brand import (
    NumberRegistrationPageResponseBrand,
)
from infobip_cpaasx.models.number_registration_page_response_brand_vet import (
    NumberRegistrationPageResponseBrandVet,
)
from infobip_cpaasx.models.number_registration_page_response_campaign import (
    NumberRegistrationPageResponseCampaign,
)
from infobip_cpaasx.models.number_registration_update_brand_request import (
    NumberRegistrationUpdateBrandRequest,
)
from infobip_cpaasx.models.number_registration_update_campaign_request import (
    NumberRegistrationUpdateCampaignRequest,
)

from infobip_cpaasx.api_client import ApiClient
from infobip_cpaasx.exceptions import ApiTypeError, ApiValueError  # noqa: F401


class NumberRegistrationApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def create_brand(
        self, number_registration_brand: NumberRegistrationBrand, **kwargs
    ) -> NumberRegistrationBrand:  # noqa: E501
        """Create Brand  # noqa: E501

        Creates a brand within the Infobip platform. This operation does not register the brand with any registrars. Registration can be done using created brand's ID with the 'Register Brand' endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_brand(number_registration_brand, async_req=True)
        >>> result = thread.get()

        :param number_registration_brand: (required)
        :type number_registration_brand: NumberRegistrationBrand
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationBrand
        """
        kwargs["_return_http_data_only"] = True
        return self.create_brand_with_http_info(
            number_registration_brand, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_brand_with_http_info(
        self, number_registration_brand: NumberRegistrationBrand, **kwargs
    ):  # noqa: E501
        """Create Brand  # noqa: E501

        Creates a brand within the Infobip platform. This operation does not register the brand with any registrars. Registration can be done using created brand's ID with the 'Register Brand' endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_brand_with_http_info(number_registration_brand, async_req=True)
        >>> result = thread.get()

        :param number_registration_brand: (required)
        :type number_registration_brand: NumberRegistrationBrand
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationBrand, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["number_registration_brand"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_brand" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_brand"]:
            _body_params = _params["number_registration_brand"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "201": "NumberRegistrationBrand",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def create_campaign(
        self, number_registration_campaign: NumberRegistrationCampaign, **kwargs
    ) -> NumberRegistrationCampaign:  # noqa: E501
        """Create Campaign  # noqa: E501

        Creates a campaign within the Infobip platform. This operation does not register the campaign with any networks. Registration can be done using created campaign's ID with the 'Register Campaign' endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_campaign(number_registration_campaign, async_req=True)
        >>> result = thread.get()

        :param number_registration_campaign: (required)
        :type number_registration_campaign: NumberRegistrationCampaign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationCampaign
        """
        kwargs["_return_http_data_only"] = True
        return self.create_campaign_with_http_info(
            number_registration_campaign, **kwargs
        )  # noqa: E501

    @validate_arguments
    def create_campaign_with_http_info(
        self, number_registration_campaign: NumberRegistrationCampaign, **kwargs
    ):  # noqa: E501
        """Create Campaign  # noqa: E501

        Creates a campaign within the Infobip platform. This operation does not register the campaign with any networks. Registration can be done using created campaign's ID with the 'Register Campaign' endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_campaign_with_http_info(number_registration_campaign, async_req=True)
        >>> result = thread.get()

        :param number_registration_campaign: (required)
        :type number_registration_campaign: NumberRegistrationCampaign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationCampaign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["number_registration_campaign"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_campaign" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_campaign"]:
            _body_params = _params["number_registration_campaign"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "201": "NumberRegistrationCampaign",
        }

        return self.api_client.call_api(
            "/number-registration/1/campaigns",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def deregister_campaign(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ) -> None:  # noqa: E501
        """Deregister Campaign  # noqa: E501

        Deregisters the campaign  with the given ID with all available networks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.deregister_campaign(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.deregister_campaign_with_http_info(
            campaign_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def deregister_campaign_with_http_info(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ):  # noqa: E501
        """Deregister Campaign  # noqa: E501

        Deregisters the campaign  with the given ID with all available networks.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.deregister_campaign_with_http_info(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["campaign_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method deregister_campaign" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["campaign_id"]:
            _path_params["campaignId"] = _params["campaign_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/number-registration/1/campaigns/{campaignId}/deregister",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_brand(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        **kwargs
    ) -> NumberRegistrationBrand:  # noqa: E501
        """Get Brand  # noqa: E501

        Retrieves a previously created brand by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand(brand_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationBrand
        """
        kwargs["_return_http_data_only"] = True
        return self.get_brand_with_http_info(brand_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_brand_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        **kwargs
    ):  # noqa: E501
        """Get Brand  # noqa: E501

        Retrieves a previously created brand by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand_with_http_info(brand_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationBrand, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["brand_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_brand" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationBrand",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_brand_registrar_statuses(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        **kwargs
    ) -> List[NumberRegistrationBrandStatus]:  # noqa: E501
        """Get Brand Registrar Statuses  # noqa: E501

        Retrieves status of a registered brand for each registrar.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand_registrar_statuses(brand_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[NumberRegistrationBrandStatus]
        """
        kwargs["_return_http_data_only"] = True
        return self.get_brand_registrar_statuses_with_http_info(
            brand_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_brand_registrar_statuses_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        **kwargs
    ):  # noqa: E501
        """Get Brand Registrar Statuses  # noqa: E501

        Retrieves status of a registered brand for each registrar.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand_registrar_statuses_with_http_info(brand_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[NumberRegistrationBrandStatus], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["brand_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_brand_registrar_statuses" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "List[NumberRegistrationBrandStatus]",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}/registrar-statuses",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_brand_vet(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        vet_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired vet.")
        ],
        **kwargs
    ) -> NumberRegistrationBrandVet:  # noqa: E501
        """Get Brand Vet  # noqa: E501

        Retrieves brand vet done for the vet with given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand_vet(brand_id, vet_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param vet_id: The ID of the desired vet. (required)
        :type vet_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationBrandVet
        """
        kwargs["_return_http_data_only"] = True
        return self.get_brand_vet_with_http_info(
            brand_id, vet_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_brand_vet_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        vet_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired vet.")
        ],
        **kwargs
    ):  # noqa: E501
        """Get Brand Vet  # noqa: E501

        Retrieves brand vet done for the vet with given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand_vet_with_http_info(brand_id, vet_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param vet_id: The ID of the desired vet. (required)
        :type vet_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationBrandVet, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["brand_id", "vet_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_brand_vet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]
        if _params["vet_id"]:
            _path_params["vetId"] = _params["vet_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationBrandVet",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}/vets/{vetId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_brand_vets(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Results page you want to retrieve (0..N). The default value is 0."
            ),
        ] = None,
        size: Annotated[
            Optional[StrictInt],
            Field(
                description="Number of records per page (0..2000). The default value is 20. The maximum value is 2000."
            ),
        ] = None,
        sort: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'type', 'vettedDate', 'enhancedVettedDate'."
            ),
        ] = None,
        **kwargs
    ) -> NumberRegistrationPageResponseBrandVet:  # noqa: E501
        """Get Brand Vets  # noqa: E501

        Retrieves all vets done for the brand with given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand_vets(brand_id, page, size, sort, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param page: Results page you want to retrieve (0..N). The default value is 0.
        :type page: int
        :param size: Number of records per page (0..2000). The default value is 20. The maximum value is 2000.
        :type size: int
        :param sort: Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'type', 'vettedDate', 'enhancedVettedDate'.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationPageResponseBrandVet
        """
        kwargs["_return_http_data_only"] = True
        return self.get_brand_vets_with_http_info(
            brand_id, page, size, sort, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_brand_vets_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Results page you want to retrieve (0..N). The default value is 0."
            ),
        ] = None,
        size: Annotated[
            Optional[StrictInt],
            Field(
                description="Number of records per page (0..2000). The default value is 20. The maximum value is 2000."
            ),
        ] = None,
        sort: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'type', 'vettedDate', 'enhancedVettedDate'."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get Brand Vets  # noqa: E501

        Retrieves all vets done for the brand with given ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brand_vets_with_http_info(brand_id, page, size, sort, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param page: Results page you want to retrieve (0..N). The default value is 0.
        :type page: int
        :param size: Number of records per page (0..2000). The default value is 20. The maximum value is 2000.
        :type size: int
        :param sort: Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'type', 'vettedDate', 'enhancedVettedDate'.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationPageResponseBrandVet, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["brand_id", "page", "size", "sort"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_brand_vets" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]

        # process the query parameters
        _query_params = []
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))
        if _params.get("size") is not None:  # noqa: E501
            _query_params.append(("size", _params["size"]))
        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"]))
            _collection_formats["sort"] = "multi"

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationPageResponseBrandVet",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}/vets",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_brands(
        self,
        id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Filters brands to those that match the supplied ID(s)."),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters brands to those that match the supplied brand types(s)."
            ),
        ] = None,
        name_like: Annotated[
            Optional[StrictStr],
            Field(
                description="Filters brands to those whose names contain the supplied name."
            ),
        ] = None,
        reference_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters brands to those that match the supplied referenceId(s)."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Results page you want to retrieve (0..N). The default value is 0."
            ),
        ] = None,
        size: Annotated[
            Optional[StrictInt],
            Field(
                description="Number of records per page (0..2000). The default value is 20. The maximum value is 2000."
            ),
        ] = None,
        sort: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'."
            ),
        ] = None,
        **kwargs
    ) -> NumberRegistrationPageResponseBrand:  # noqa: E501
        """Get Brands  # noqa: E501

        Get a page of brands, using query parameters to filter results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brands(id, type, name_like, reference_id, page, size, sort, async_req=True)
        >>> result = thread.get()

        :param id: Filters brands to those that match the supplied ID(s).
        :type id: List[str]
        :param type: Filters brands to those that match the supplied brand types(s).
        :type type: List[str]
        :param name_like: Filters brands to those whose names contain the supplied name.
        :type name_like: str
        :param reference_id: Filters brands to those that match the supplied referenceId(s).
        :type reference_id: List[str]
        :param page: Results page you want to retrieve (0..N). The default value is 0.
        :type page: int
        :param size: Number of records per page (0..2000). The default value is 20. The maximum value is 2000.
        :type size: int
        :param sort: Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationPageResponseBrand
        """
        kwargs["_return_http_data_only"] = True
        return self.get_brands_with_http_info(
            id, type, name_like, reference_id, page, size, sort, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_brands_with_http_info(
        self,
        id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Filters brands to those that match the supplied ID(s)."),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters brands to those that match the supplied brand types(s)."
            ),
        ] = None,
        name_like: Annotated[
            Optional[StrictStr],
            Field(
                description="Filters brands to those whose names contain the supplied name."
            ),
        ] = None,
        reference_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters brands to those that match the supplied referenceId(s)."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Results page you want to retrieve (0..N). The default value is 0."
            ),
        ] = None,
        size: Annotated[
            Optional[StrictInt],
            Field(
                description="Number of records per page (0..2000). The default value is 20. The maximum value is 2000."
            ),
        ] = None,
        sort: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get Brands  # noqa: E501

        Get a page of brands, using query parameters to filter results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_brands_with_http_info(id, type, name_like, reference_id, page, size, sort, async_req=True)
        >>> result = thread.get()

        :param id: Filters brands to those that match the supplied ID(s).
        :type id: List[str]
        :param type: Filters brands to those that match the supplied brand types(s).
        :type type: List[str]
        :param name_like: Filters brands to those whose names contain the supplied name.
        :type name_like: str
        :param reference_id: Filters brands to those that match the supplied referenceId(s).
        :type reference_id: List[str]
        :param page: Results page you want to retrieve (0..N). The default value is 0.
        :type page: int
        :param size: Number of records per page (0..2000). The default value is 20. The maximum value is 2000.
        :type size: int
        :param sort: Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationPageResponseBrand, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "id",
            "type",
            "name_like",
            "reference_id",
            "page",
            "size",
            "sort",
        ]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_brands" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("id") is not None:  # noqa: E501
            _query_params.append(("id", _params["id"]))
            _collection_formats["id"] = "multi"
        if _params.get("type") is not None:  # noqa: E501
            _query_params.append(("type", _params["type"]))
            _collection_formats["type"] = "multi"
        if _params.get("name_like") is not None:  # noqa: E501
            _query_params.append(("nameLike", _params["name_like"]))
        if _params.get("reference_id") is not None:  # noqa: E501
            _query_params.append(("referenceId", _params["reference_id"]))
            _collection_formats["referenceId"] = "multi"
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))
        if _params.get("size") is not None:  # noqa: E501
            _query_params.append(("size", _params["size"]))
        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"]))
            _collection_formats["sort"] = "multi"

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationPageResponseBrand",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_campaign(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ) -> NumberRegistrationCampaign:  # noqa: E501
        """Get Campaign  # noqa: E501

        Retrieves a previously created campaign  by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_campaign(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationCampaign
        """
        kwargs["_return_http_data_only"] = True
        return self.get_campaign_with_http_info(campaign_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_campaign_with_http_info(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ):  # noqa: E501
        """Get Campaign  # noqa: E501

        Retrieves a previously created campaign  by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_campaign_with_http_info(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationCampaign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["campaign_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["campaign_id"]:
            _path_params["campaignId"] = _params["campaign_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationCampaign",
        }

        return self.api_client.call_api(
            "/number-registration/1/campaigns/{campaignId}",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_campaign_network_statuses(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ) -> List[NumberRegistrationNetworkStatus]:  # noqa: E501
        """Get Campaign Network Statuses  # noqa: E501

        Retrieves status of a registered campaign for each network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_campaign_network_statuses(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[NumberRegistrationNetworkStatus]
        """
        kwargs["_return_http_data_only"] = True
        return self.get_campaign_network_statuses_with_http_info(
            campaign_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_campaign_network_statuses_with_http_info(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ):  # noqa: E501
        """Get Campaign Network Statuses  # noqa: E501

        Retrieves status of a registered campaign for each network.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_campaign_network_statuses_with_http_info(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[NumberRegistrationNetworkStatus], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["campaign_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign_network_statuses" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["campaign_id"]:
            _path_params["campaignId"] = _params["campaign_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "List[NumberRegistrationNetworkStatus]",
        }

        return self.api_client.call_api(
            "/number-registration/1/campaigns/{campaignId}/network-statuses",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_campaigns(
        self,
        id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied ID(s)."
            ),
        ] = None,
        brand_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied brand ID(s)."
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied campaign type(s)."
            ),
        ] = None,
        name_like: Annotated[
            Optional[StrictStr],
            Field(
                description="Filters campaigns to those whose names contain the supplied name. "
            ),
        ] = None,
        reference_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied referenceId(s)."
            ),
        ] = None,
        stage: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the campaign stage(s)."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Results page you want to retrieve (0..N). The default value is 0."
            ),
        ] = None,
        size: Annotated[
            Optional[StrictInt],
            Field(
                description="Number of records per page (0..2000). The default value is 20. The maximum value is 2000."
            ),
        ] = None,
        sort: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'."
            ),
        ] = None,
        **kwargs
    ) -> NumberRegistrationPageResponseCampaign:  # noqa: E501
        """Get Campaigns  # noqa: E501

        Get a page of campaigns, using query parameters to filter results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_campaigns(id, brand_id, type, name_like, reference_id, stage, page, size, sort, async_req=True)
        >>> result = thread.get()

        :param id: Filters campaigns to those that match the supplied ID(s).
        :type id: List[str]
        :param brand_id: Filters campaigns to those that match the supplied brand ID(s).
        :type brand_id: List[str]
        :param type: Filters campaigns to those that match the supplied campaign type(s).
        :type type: List[str]
        :param name_like: Filters campaigns to those whose names contain the supplied name.
        :type name_like: str
        :param reference_id: Filters campaigns to those that match the supplied referenceId(s).
        :type reference_id: List[str]
        :param stage: Filters campaigns to those that match the campaign stage(s).
        :type stage: List[str]
        :param page: Results page you want to retrieve (0..N). The default value is 0.
        :type page: int
        :param size: Number of records per page (0..2000). The default value is 20. The maximum value is 2000.
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationPageResponseCampaign
        """
        kwargs["_return_http_data_only"] = True
        return self.get_campaigns_with_http_info(
            id,
            brand_id,
            type,
            name_like,
            reference_id,
            stage,
            page,
            size,
            sort,
            **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_campaigns_with_http_info(
        self,
        id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied ID(s)."
            ),
        ] = None,
        brand_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied brand ID(s)."
            ),
        ] = None,
        type: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied campaign type(s)."
            ),
        ] = None,
        name_like: Annotated[
            Optional[StrictStr],
            Field(
                description="Filters campaigns to those whose names contain the supplied name. "
            ),
        ] = None,
        reference_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the supplied referenceId(s)."
            ),
        ] = None,
        stage: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Filters campaigns to those that match the campaign stage(s)."
            ),
        ] = None,
        page: Annotated[
            Optional[StrictInt],
            Field(
                description="Results page you want to retrieve (0..N). The default value is 0."
            ),
        ] = None,
        size: Annotated[
            Optional[StrictInt],
            Field(
                description="Number of records per page (0..2000). The default value is 20. The maximum value is 2000."
            ),
        ] = None,
        sort: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get Campaigns  # noqa: E501

        Get a page of campaigns, using query parameters to filter results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_campaigns_with_http_info(id, brand_id, type, name_like, reference_id, stage, page, size, sort, async_req=True)
        >>> result = thread.get()

        :param id: Filters campaigns to those that match the supplied ID(s).
        :type id: List[str]
        :param brand_id: Filters campaigns to those that match the supplied brand ID(s).
        :type brand_id: List[str]
        :param type: Filters campaigns to those that match the supplied campaign type(s).
        :type type: List[str]
        :param name_like: Filters campaigns to those whose names contain the supplied name.
        :type name_like: str
        :param reference_id: Filters campaigns to those that match the supplied referenceId(s).
        :type reference_id: List[str]
        :param stage: Filters campaigns to those that match the campaign stage(s).
        :type stage: List[str]
        :param page: Results page you want to retrieve (0..N). The default value is 0.
        :type page: int
        :param size: Number of records per page (0..2000). The default value is 20. The maximum value is 2000.
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Sortable Properties: 'id', 'name', 'type', 'createdDate', 'lastModifiedDate'.
        :type sort: List[str]
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationPageResponseCampaign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "id",
            "brand_id",
            "type",
            "name_like",
            "reference_id",
            "stage",
            "page",
            "size",
            "sort",
        ]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaigns" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("id") is not None:  # noqa: E501
            _query_params.append(("id", _params["id"]))
            _collection_formats["id"] = "multi"
        if _params.get("brand_id") is not None:  # noqa: E501
            _query_params.append(("brandId", _params["brand_id"]))
            _collection_formats["brandId"] = "multi"
        if _params.get("type") is not None:  # noqa: E501
            _query_params.append(("type", _params["type"]))
            _collection_formats["type"] = "multi"
        if _params.get("name_like") is not None:  # noqa: E501
            _query_params.append(("nameLike", _params["name_like"]))
        if _params.get("reference_id") is not None:  # noqa: E501
            _query_params.append(("referenceId", _params["reference_id"]))
            _collection_formats["referenceId"] = "multi"
        if _params.get("stage") is not None:  # noqa: E501
            _query_params.append(("stage", _params["stage"]))
            _collection_formats["stage"] = "multi"
        if _params.get("page") is not None:  # noqa: E501
            _query_params.append(("page", _params["page"]))
        if _params.get("size") is not None:  # noqa: E501
            _query_params.append(("size", _params["size"]))
        if _params.get("sort") is not None:  # noqa: E501
            _query_params.append(("sort", _params["sort"]))
            _collection_formats["sort"] = "multi"

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationPageResponseCampaign",
        }

        return self.api_client.call_api(
            "/number-registration/1/campaigns",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def register_brand(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        **kwargs
    ) -> None:  # noqa: E501
        """Register Brand  # noqa: E501

        Registers the brand with the given ID with all available registrars. Each registered brand incurs a cost, consult your contract for pricing details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_brand(brand_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.register_brand_with_http_info(brand_id, **kwargs)  # noqa: E501

    @validate_arguments
    def register_brand_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        **kwargs
    ):  # noqa: E501
        """Register Brand  # noqa: E501

        Registers the brand with the given ID with all available registrars. Each registered brand incurs a cost, consult your contract for pricing details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_brand_with_http_info(brand_id, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["brand_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_brand" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}/register",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def register_campaign(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ) -> None:  # noqa: E501
        """Register Campaign  # noqa: E501

        Registers the campaign  with the given ID with all available networks. Each registered campaign incurs a cost, consult your contract for pricing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_campaign(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.register_campaign_with_http_info(
            campaign_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def register_campaign_with_http_info(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        **kwargs
    ):  # noqa: E501
        """Register Campaign  # noqa: E501

        Registers the campaign  with the given ID with all available networks. Each registered campaign incurs a cost, consult your contract for pricing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.register_campaign_with_http_info(campaign_id, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["campaign_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_campaign" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["campaign_id"]:
            _path_params["campaignId"] = _params["campaign_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/number-registration/1/campaigns/{campaignId}/register",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_brand(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        number_registration_brand: NumberRegistrationBrand,
        **kwargs
    ) -> NumberRegistrationBrand:  # noqa: E501
        """Update Brand  # noqa: E501

        Updates a brand that has not yet been registered within the Infobip platform or that has a failed registration. After a brand has been successfully registered, this method is no longer supported and will return a 405 Method Not Allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_brand(brand_id, number_registration_brand, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param number_registration_brand: (required)
        :type number_registration_brand: NumberRegistrationBrand
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationBrand
        """
        kwargs["_return_http_data_only"] = True
        return self.update_brand_with_http_info(
            brand_id, number_registration_brand, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_brand_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        number_registration_brand: NumberRegistrationBrand,
        **kwargs
    ):  # noqa: E501
        """Update Brand  # noqa: E501

        Updates a brand that has not yet been registered within the Infobip platform or that has a failed registration. After a brand has been successfully registered, this method is no longer supported and will return a 405 Method Not Allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_brand_with_http_info(brand_id, number_registration_brand, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param number_registration_brand: (required)
        :type number_registration_brand: NumberRegistrationBrand
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationBrand, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["brand_id", "number_registration_brand"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_brand" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_brand"]:
            _body_params = _params["number_registration_brand"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationBrand",
            "202": "NumberRegistrationBrand",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_brand_vet(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        vet_id: Annotated[
            StrictStr, Field(..., description="The ID of the brand active vet.")
        ],
        number_registration_brand_vet: NumberRegistrationBrandVet,
        **kwargs
    ) -> NumberRegistrationBrandVet:  # noqa: E501
        """Update Brand Vet  # noqa: E501

        Updates a brand vet's type. Provided vet must be current active standard vet and it may only be updated to an enhanced vet if it was performed within the last 30 days. All other attempts to update a vet are considered an error.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_brand_vet(brand_id, vet_id, number_registration_brand_vet, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param vet_id: The ID of the brand active vet. (required)
        :type vet_id: str
        :param number_registration_brand_vet: (required)
        :type number_registration_brand_vet: NumberRegistrationBrandVet
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationBrandVet
        """
        kwargs["_return_http_data_only"] = True
        return self.update_brand_vet_with_http_info(
            brand_id, vet_id, number_registration_brand_vet, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_brand_vet_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        vet_id: Annotated[
            StrictStr, Field(..., description="The ID of the brand active vet.")
        ],
        number_registration_brand_vet: NumberRegistrationBrandVet,
        **kwargs
    ):  # noqa: E501
        """Update Brand Vet  # noqa: E501

        Updates a brand vet's type. Provided vet must be current active standard vet and it may only be updated to an enhanced vet if it was performed within the last 30 days. All other attempts to update a vet are considered an error.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_brand_vet_with_http_info(brand_id, vet_id, number_registration_brand_vet, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param vet_id: The ID of the brand active vet. (required)
        :type vet_id: str
        :param number_registration_brand_vet: (required)
        :type number_registration_brand_vet: NumberRegistrationBrandVet
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationBrandVet, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["brand_id", "vet_id", "number_registration_brand_vet"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_brand_vet" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]
        if _params["vet_id"]:
            _path_params["vetId"] = _params["vet_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_brand_vet"]:
            _body_params = _params["number_registration_brand_vet"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationBrandVet",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}/vets/{vetId}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_campaign(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        number_registration_campaign: NumberRegistrationCampaign,
        **kwargs
    ) -> NumberRegistrationCampaign:  # noqa: E501
        """Update Campaign  # noqa: E501

        Updates a campaign that has not yet been registered within the Infobip platform. After a campaign has been registered, this method is no longer supported and will return a 405 Method Not Allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_campaign(campaign_id, number_registration_campaign, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param number_registration_campaign: (required)
        :type number_registration_campaign: NumberRegistrationCampaign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationCampaign
        """
        kwargs["_return_http_data_only"] = True
        return self.update_campaign_with_http_info(
            campaign_id, number_registration_campaign, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_campaign_with_http_info(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        number_registration_campaign: NumberRegistrationCampaign,
        **kwargs
    ):  # noqa: E501
        """Update Campaign  # noqa: E501

        Updates a campaign that has not yet been registered within the Infobip platform. After a campaign has been registered, this method is no longer supported and will return a 405 Method Not Allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_campaign_with_http_info(campaign_id, number_registration_campaign, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param number_registration_campaign: (required)
        :type number_registration_campaign: NumberRegistrationCampaign
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationCampaign, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["campaign_id", "number_registration_campaign"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_campaign" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["campaign_id"]:
            _path_params["campaignId"] = _params["campaign_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_campaign"]:
            _body_params = _params["number_registration_campaign"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "NumberRegistrationCampaign",
        }

        return self.api_client.call_api(
            "/number-registration/1/campaigns/{campaignId}",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_registered_brand(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        number_registration_update_brand_request: NumberRegistrationUpdateBrandRequest,
        **kwargs
    ) -> None:  # noqa: E501
        """Update Registered Brand  # noqa: E501

        Updates a brand that has already been registered. If the brand has not been submitted for registration, or is already 'VERIFIED', attempting to update via this api will result in a 405 Method Not Allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_registered_brand(brand_id, number_registration_update_brand_request, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param number_registration_update_brand_request: (required)
        :type number_registration_update_brand_request: NumberRegistrationUpdateBrandRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.update_registered_brand_with_http_info(
            brand_id, number_registration_update_brand_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_registered_brand_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        number_registration_update_brand_request: NumberRegistrationUpdateBrandRequest,
        **kwargs
    ):  # noqa: E501
        """Update Registered Brand  # noqa: E501

        Updates a brand that has already been registered. If the brand has not been submitted for registration, or is already 'VERIFIED', attempting to update via this api will result in a 405 Method Not Allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_registered_brand_with_http_info(brand_id, number_registration_update_brand_request, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param number_registration_update_brand_request: (required)
        :type number_registration_update_brand_request: NumberRegistrationUpdateBrandRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["brand_id", "number_registration_update_brand_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_registered_brand" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_update_brand_request"]:
            _body_params = _params["number_registration_update_brand_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}/update-registration",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_registered_campaign(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        number_registration_update_campaign_request: NumberRegistrationUpdateCampaignRequest,
        **kwargs
    ) -> None:  # noqa: E501
        """Update Registered Campaign  # noqa: E501

        Updates a campaign that has already been registered. If registration has not completed for the campaign, attempting to update via this api will result in a 400 Bad Request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_registered_campaign(campaign_id, number_registration_update_campaign_request, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param number_registration_update_campaign_request: (required)
        :type number_registration_update_campaign_request: NumberRegistrationUpdateCampaignRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs["_return_http_data_only"] = True
        return self.update_registered_campaign_with_http_info(
            campaign_id, number_registration_update_campaign_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_registered_campaign_with_http_info(
        self,
        campaign_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired campaign.")
        ],
        number_registration_update_campaign_request: NumberRegistrationUpdateCampaignRequest,
        **kwargs
    ):  # noqa: E501
        """Update Registered Campaign  # noqa: E501

        Updates a campaign that has already been registered. If registration has not completed for the campaign, attempting to update via this api will result in a 400 Bad Request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_registered_campaign_with_http_info(campaign_id, number_registration_update_campaign_request, async_req=True)
        >>> result = thread.get()

        :param campaign_id: The ID of the desired campaign. (required)
        :type campaign_id: str
        :param number_registration_update_campaign_request: (required)
        :type number_registration_update_campaign_request: NumberRegistrationUpdateCampaignRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = ["campaign_id", "number_registration_update_campaign_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_registered_campaign" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["campaign_id"]:
            _path_params["campaignId"] = _params["campaign_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_update_campaign_request"]:
            _body_params = _params["number_registration_update_campaign_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            "/number-registration/1/campaigns/{campaignId}/update-registration",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def vet_brand(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        number_registration_brand_vet: NumberRegistrationBrandVet,
        **kwargs
    ) -> NumberRegistrationBrandVet:  # noqa: E501
        """Vet Brand  # noqa: E501

        Vets the brand with the given key. Vetting a brand may only be performed once every 30 days. Each vet of a brand incurs a cost, consult your contract for pricing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vet_brand(brand_id, number_registration_brand_vet, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param number_registration_brand_vet: (required)
        :type number_registration_brand_vet: NumberRegistrationBrandVet
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: NumberRegistrationBrandVet
        """
        kwargs["_return_http_data_only"] = True
        return self.vet_brand_with_http_info(
            brand_id, number_registration_brand_vet, **kwargs
        )  # noqa: E501

    @validate_arguments
    def vet_brand_with_http_info(
        self,
        brand_id: Annotated[
            StrictStr, Field(..., description="The ID of the desired brand.")
        ],
        number_registration_brand_vet: NumberRegistrationBrandVet,
        **kwargs
    ):  # noqa: E501
        """Vet Brand  # noqa: E501

        Vets the brand with the given key. Vetting a brand may only be performed once every 30 days. Each vet of a brand incurs a cost, consult your contract for pricing information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vet_brand_with_http_info(brand_id, number_registration_brand_vet, async_req=True)
        >>> result = thread.get()

        :param brand_id: The ID of the desired brand. (required)
        :type brand_id: str
        :param number_registration_brand_vet: (required)
        :type number_registration_brand_vet: NumberRegistrationBrandVet
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(NumberRegistrationBrandVet, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["brand_id", "number_registration_brand_vet"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vet_brand" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params["brand_id"]:
            _path_params["brandId"] = _params["brand_id"]

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["number_registration_brand_vet"]:
            _body_params = _params["number_registration_brand_vet"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "202": "NumberRegistrationBrandVet",
        }

        return self.api_client.call_api(
            "/number-registration/1/brands/{brandId}/vets",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
