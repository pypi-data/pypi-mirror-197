# coding: utf-8

"""
    This class is auto generated from the Infobip OpenAPI specification
    through the OpenAPI Specification Client API libraries (Re)Generator (OSCAR),
    powered by the OpenAPI Generator (https://openapi-generator.tech).
"""


from __future__ import absolute_import

import re  # noqa: F401

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictInt, StrictStr, conint

from typing import List, Optional

from infobip_cpaasx.models.sms_advanced_binary_request import SmsAdvancedBinaryRequest
from infobip_cpaasx.models.sms_advanced_textual_request import SmsAdvancedTextualRequest
from infobip_cpaasx.models.sms_bulk_request import SmsBulkRequest
from infobip_cpaasx.models.sms_bulk_response import SmsBulkResponse
from infobip_cpaasx.models.sms_bulk_status_response import SmsBulkStatusResponse
from infobip_cpaasx.models.sms_delivery_result import SmsDeliveryResult
from infobip_cpaasx.models.sms_inbound_message_result import SmsInboundMessageResult
from infobip_cpaasx.models.sms_logs_response import SmsLogsResponse
from infobip_cpaasx.models.sms_preview_request import SmsPreviewRequest
from infobip_cpaasx.models.sms_preview_response import SmsPreviewResponse
from infobip_cpaasx.models.sms_response import SmsResponse
from infobip_cpaasx.models.sms_update_status_request import SmsUpdateStatusRequest

from infobip_cpaasx.api_client import ApiClient
from infobip_cpaasx.exceptions import ApiTypeError, ApiValueError  # noqa: F401


class SmsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def get_inbound_sms_messages(
        self,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of messages to be returned in a response. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access messages for the last 48h."
            ),
        ] = None,
        **kwargs
    ) -> SmsInboundMessageResult:  # noqa: E501
        """Get inbound SMS messages  # noqa: E501

        If for some reason you are unable to receive incoming SMS to the endpoint of your choice in real time, you can use this API call to fetch messages. Each request will return a batch of received messages - only once. The API request will only return new messages that arrived since the last API request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_inbound_sms_messages(limit, async_req=True)
        >>> result = thread.get()

        :param limit: Maximum number of messages to be returned in a response. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access messages for the last 48h.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsInboundMessageResult
        """
        kwargs["_return_http_data_only"] = True
        return self.get_inbound_sms_messages_with_http_info(
            limit, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_inbound_sms_messages_with_http_info(
        self,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of messages to be returned in a response. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access messages for the last 48h."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get inbound SMS messages  # noqa: E501

        If for some reason you are unable to receive incoming SMS to the endpoint of your choice in real time, you can use this API call to fetch messages. Each request will return a batch of received messages - only once. The API request will only return new messages that arrived since the last API request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_inbound_sms_messages_with_http_info(limit, async_req=True)
        >>> result = thread.get()

        :param limit: Maximum number of messages to be returned in a response. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access messages for the last 48h.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsInboundMessageResult, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["limit"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_inbound_sms_messages" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsInboundMessageResult",
        }

        return self.api_client.call_api(
            "/sms/1/inbox/reports",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_outbound_sms_message_delivery_reports(
        self,
        bulk_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request."
            ),
        ] = None,
        message_id: Annotated[
            Optional[StrictStr],
            Field(description="Unique message ID for which a report is requested."),
        ] = None,
        limit: Annotated[
            Optional[conint(strict=True, le=1000)],
            Field(
                description="Maximum number of delivery reports to be returned. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access reports for the last 48h."
            ),
        ] = None,
        **kwargs
    ) -> SmsDeliveryResult:  # noqa: E501
        """Get outbound SMS message delivery reports  # noqa: E501

        If you are for any reason unable to receive real-time delivery reports on your endpoint, you can use this API method to learn if and when the message has been delivered to the recipient. Each request will return a batch of delivery reports - only once. The following API request will return only new reports that arrived since the last API request in the last 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_outbound_sms_message_delivery_reports(bulk_id, message_id, limit, async_req=True)
        >>> result = thread.get()

        :param bulk_id: Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request.
        :type bulk_id: str
        :param message_id: Unique message ID for which a report is requested.
        :type message_id: str
        :param limit: Maximum number of delivery reports to be returned. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access reports for the last 48h.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsDeliveryResult
        """
        kwargs["_return_http_data_only"] = True
        return self.get_outbound_sms_message_delivery_reports_with_http_info(
            bulk_id, message_id, limit, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_outbound_sms_message_delivery_reports_with_http_info(
        self,
        bulk_id: Annotated[
            Optional[StrictStr],
            Field(
                description="Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request."
            ),
        ] = None,
        message_id: Annotated[
            Optional[StrictStr],
            Field(description="Unique message ID for which a report is requested."),
        ] = None,
        limit: Annotated[
            Optional[conint(strict=True, le=1000)],
            Field(
                description="Maximum number of delivery reports to be returned. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access reports for the last 48h."
            ),
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get outbound SMS message delivery reports  # noqa: E501

        If you are for any reason unable to receive real-time delivery reports on your endpoint, you can use this API method to learn if and when the message has been delivered to the recipient. Each request will return a batch of delivery reports - only once. The following API request will return only new reports that arrived since the last API request in the last 48 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_outbound_sms_message_delivery_reports_with_http_info(bulk_id, message_id, limit, async_req=True)
        >>> result = thread.get()

        :param bulk_id: Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request.
        :type bulk_id: str
        :param message_id: Unique message ID for which a report is requested.
        :type message_id: str
        :param limit: Maximum number of delivery reports to be returned. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access reports for the last 48h.
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsDeliveryResult, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["bulk_id", "message_id", "limit"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_outbound_sms_message_delivery_reports" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("bulk_id") is not None:  # noqa: E501
            _query_params.append(("bulkId", _params["bulk_id"]))
        if _params.get("message_id") is not None:  # noqa: E501
            _query_params.append(("messageId", _params["message_id"]))
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsDeliveryResult",
        }

        return self.api_client.call_api(
            "/sms/1/reports",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_outbound_sms_message_logs(
        self,
        var_from: Annotated[
            Optional[StrictStr],
            Field(description="The sender ID which can be alphanumeric or numeric."),
        ] = None,
        to: Annotated[
            Optional[StrictStr], Field(description="Message destination address.")
        ] = None,
        bulk_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request."
            ),
        ] = None,
        message_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Unique message ID for which a log is requested."),
        ] = None,
        general_status: Annotated[
            Optional[StrictStr],
            Field(
                description="Sent [message status](https://www.infobip.com/docs/essentials/response-status-and-error-codes#api-status-codes). Possible values: `ACCEPTED`, `PENDING`, `UNDELIVERABLE`, `DELIVERED`, `REJECTED`, `EXPIRED`."
            ),
        ] = None,
        sent_since: Annotated[
            Optional[datetime],
            Field(
                description="The logs will only include messages sent after this date. Use it together with `sentUntil` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`."
            ),
        ] = None,
        sent_until: Annotated[
            Optional[datetime],
            Field(
                description="The logs will only include messages sent before this date. Use it together with `sentBefore` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of messages to include in logs. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access logs for the last 48h. If you want to fetch more than 1000 logs allowed per call, use `sentBefore` and `sentUntil` to retrieve them in pages."
            ),
        ] = None,
        mcc: Annotated[
            Optional[StrictStr], Field(description="Mobile Country Code.")
        ] = None,
        mnc: Annotated[
            Optional[StrictStr], Field(description="Mobile Network Code.")
        ] = None,
        **kwargs
    ) -> SmsLogsResponse:  # noqa: E501
        """Get outbound SMS message logs  # noqa: E501

        Use this method for displaying logs for example in the user interface. Available are the logs for the last 48 hours and you can only retrieve maximum of 1000 logs per call. See [message delivery reports](#channels/sms/get-outbound-sms-message-delivery-reports) if your use case is to verify message delivery.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_outbound_sms_message_logs(var_from, to, bulk_id, message_id, general_status, sent_since, sent_until, limit, mcc, mnc, async_req=True)
        >>> result = thread.get()

        :param var_from: The sender ID which can be alphanumeric or numeric.
        :type var_from: str
        :param to: Message destination address.
        :type to: str
        :param bulk_id: Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request.
        :type bulk_id: List[str]
        :param message_id: Unique message ID for which a log is requested.
        :type message_id: List[str]
        :param general_status: Sent [message status](https://www.infobip.com/docs/essentials/response-status-and-error-codes#api-status-codes). Possible values: `ACCEPTED`, `PENDING`, `UNDELIVERABLE`, `DELIVERED`, `REJECTED`, `EXPIRED`.
        :type general_status: str
        :param sent_since: The logs will only include messages sent after this date. Use it together with `sentUntil` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
        :type sent_since: datetime
        :param sent_until: The logs will only include messages sent before this date. Use it together with `sentBefore` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
        :type sent_until: datetime
        :param limit: Maximum number of messages to include in logs. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access logs for the last 48h. If you want to fetch more than 1000 logs allowed per call, use `sentBefore` and `sentUntil` to retrieve them in pages.
        :type limit: int
        :param mcc: Mobile Country Code.
        :type mcc: str
        :param mnc: Mobile Network Code.
        :type mnc: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsLogsResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.get_outbound_sms_message_logs_with_http_info(
            var_from,
            to,
            bulk_id,
            message_id,
            general_status,
            sent_since,
            sent_until,
            limit,
            mcc,
            mnc,
            **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_outbound_sms_message_logs_with_http_info(
        self,
        var_from: Annotated[
            Optional[StrictStr],
            Field(description="The sender ID which can be alphanumeric or numeric."),
        ] = None,
        to: Annotated[
            Optional[StrictStr], Field(description="Message destination address.")
        ] = None,
        bulk_id: Annotated[
            Optional[List[StrictStr]],
            Field(
                description="Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request."
            ),
        ] = None,
        message_id: Annotated[
            Optional[List[StrictStr]],
            Field(description="Unique message ID for which a log is requested."),
        ] = None,
        general_status: Annotated[
            Optional[StrictStr],
            Field(
                description="Sent [message status](https://www.infobip.com/docs/essentials/response-status-and-error-codes#api-status-codes). Possible values: `ACCEPTED`, `PENDING`, `UNDELIVERABLE`, `DELIVERED`, `REJECTED`, `EXPIRED`."
            ),
        ] = None,
        sent_since: Annotated[
            Optional[datetime],
            Field(
                description="The logs will only include messages sent after this date. Use it together with `sentUntil` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`."
            ),
        ] = None,
        sent_until: Annotated[
            Optional[datetime],
            Field(
                description="The logs will only include messages sent before this date. Use it together with `sentBefore` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Maximum number of messages to include in logs. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access logs for the last 48h. If you want to fetch more than 1000 logs allowed per call, use `sentBefore` and `sentUntil` to retrieve them in pages."
            ),
        ] = None,
        mcc: Annotated[
            Optional[StrictStr], Field(description="Mobile Country Code.")
        ] = None,
        mnc: Annotated[
            Optional[StrictStr], Field(description="Mobile Network Code.")
        ] = None,
        **kwargs
    ):  # noqa: E501
        """Get outbound SMS message logs  # noqa: E501

        Use this method for displaying logs for example in the user interface. Available are the logs for the last 48 hours and you can only retrieve maximum of 1000 logs per call. See [message delivery reports](#channels/sms/get-outbound-sms-message-delivery-reports) if your use case is to verify message delivery.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_outbound_sms_message_logs_with_http_info(var_from, to, bulk_id, message_id, general_status, sent_since, sent_until, limit, mcc, mnc, async_req=True)
        >>> result = thread.get()

        :param var_from: The sender ID which can be alphanumeric or numeric.
        :type var_from: str
        :param to: Message destination address.
        :type to: str
        :param bulk_id: Unique ID assigned to the request if messaging multiple recipients or sending multiple messages via a single API request.
        :type bulk_id: List[str]
        :param message_id: Unique message ID for which a log is requested.
        :type message_id: List[str]
        :param general_status: Sent [message status](https://www.infobip.com/docs/essentials/response-status-and-error-codes#api-status-codes). Possible values: `ACCEPTED`, `PENDING`, `UNDELIVERABLE`, `DELIVERED`, `REJECTED`, `EXPIRED`.
        :type general_status: str
        :param sent_since: The logs will only include messages sent after this date. Use it together with `sentUntil` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
        :type sent_since: datetime
        :param sent_until: The logs will only include messages sent before this date. Use it together with `sentBefore` to return a time range or if you want to fetch more than 1000 logs allowed per call. Has the following format: `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
        :type sent_until: datetime
        :param limit: Maximum number of messages to include in logs. If not set, the latest 50 records are returned. Maximum limit value is `1000` and you can only access logs for the last 48h. If you want to fetch more than 1000 logs allowed per call, use `sentBefore` and `sentUntil` to retrieve them in pages.
        :type limit: int
        :param mcc: Mobile Country Code.
        :type mcc: str
        :param mnc: Mobile Network Code.
        :type mnc: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsLogsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            "var_from",
            "to",
            "bulk_id",
            "message_id",
            "general_status",
            "sent_since",
            "sent_until",
            "limit",
            "mcc",
            "mnc",
        ]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_outbound_sms_message_logs" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("var_from") is not None:  # noqa: E501
            _query_params.append(("from", _params["var_from"]))
        if _params.get("to") is not None:  # noqa: E501
            _query_params.append(("to", _params["to"]))
        if _params.get("bulk_id") is not None:  # noqa: E501
            _query_params.append(("bulkId", _params["bulk_id"]))
            _collection_formats["bulkId"] = "multi"
        if _params.get("message_id") is not None:  # noqa: E501
            _query_params.append(("messageId", _params["message_id"]))
            _collection_formats["messageId"] = "multi"
        if _params.get("general_status") is not None:  # noqa: E501
            _query_params.append(("generalStatus", _params["general_status"]))
        if _params.get("sent_since") is not None:  # noqa: E501
            _query_params.append(("sentSince", _params["sent_since"]))
        if _params.get("sent_until") is not None:  # noqa: E501
            _query_params.append(("sentUntil", _params["sent_until"]))
        if _params.get("limit") is not None:  # noqa: E501
            _query_params.append(("limit", _params["limit"]))
        if _params.get("mcc") is not None:  # noqa: E501
            _query_params.append(("mcc", _params["mcc"]))
        if _params.get("mnc") is not None:  # noqa: E501
            _query_params.append(("mnc", _params["mnc"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsLogsResponse",
        }

        return self.api_client.call_api(
            "/sms/1/logs",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_scheduled_sms_messages(
        self, bulk_id: StrictStr, **kwargs
    ) -> SmsBulkResponse:  # noqa: E501
        """Get scheduled SMS messages  # noqa: E501

        See all scheduled messages and their scheduled date and time. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_sms_messages(bulk_id, async_req=True)
        >>> result = thread.get()

        :param bulk_id:  (required)
        :type bulk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsBulkResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.get_scheduled_sms_messages_with_http_info(
            bulk_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_scheduled_sms_messages_with_http_info(
        self, bulk_id: StrictStr, **kwargs
    ):  # noqa: E501
        """Get scheduled SMS messages  # noqa: E501

        See all scheduled messages and their scheduled date and time. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_sms_messages_with_http_info(bulk_id, async_req=True)
        >>> result = thread.get()

        :param bulk_id:  (required)
        :type bulk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsBulkResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["bulk_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scheduled_sms_messages" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("bulk_id") is not None:  # noqa: E501
            _query_params.append(("bulkId", _params["bulk_id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsBulkResponse",
        }

        return self.api_client.call_api(
            "/sms/1/bulks",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def get_scheduled_sms_messages_status(
        self, bulk_id: StrictStr, **kwargs
    ) -> SmsBulkStatusResponse:  # noqa: E501
        """Get scheduled SMS messages status  # noqa: E501

        See the status of scheduled messages. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_sms_messages_status(bulk_id, async_req=True)
        >>> result = thread.get()

        :param bulk_id: (required)
        :type bulk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsBulkStatusResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.get_scheduled_sms_messages_status_with_http_info(
            bulk_id, **kwargs
        )  # noqa: E501

    @validate_arguments
    def get_scheduled_sms_messages_status_with_http_info(
        self, bulk_id: StrictStr, **kwargs
    ):  # noqa: E501
        """Get scheduled SMS messages status  # noqa: E501

        See the status of scheduled messages. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_scheduled_sms_messages_status_with_http_info(bulk_id, async_req=True)
        >>> result = thread.get()

        :param bulk_id: (required)
        :type bulk_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsBulkStatusResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["bulk_id"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_scheduled_sms_messages_status" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("bulk_id") is not None:  # noqa: E501
            _query_params.append(("bulkId", _params["bulk_id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsBulkStatusResponse",
        }

        return self.api_client.call_api(
            "/sms/1/bulks/status",
            "GET",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def preview_sms_message(
        self, sms_preview_request: SmsPreviewRequest, **kwargs
    ) -> SmsPreviewResponse:  # noqa: E501
        """Preview SMS message  # noqa: E501

        Avoid unpleasant surprises and check how different message configurations will affect your message text, number of characters and message parts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.preview_sms_message(sms_preview_request, async_req=True)
        >>> result = thread.get()

        :param sms_preview_request: (required)
        :type sms_preview_request: SmsPreviewRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsPreviewResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.preview_sms_message_with_http_info(
            sms_preview_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def preview_sms_message_with_http_info(
        self, sms_preview_request: SmsPreviewRequest, **kwargs
    ):  # noqa: E501
        """Preview SMS message  # noqa: E501

        Avoid unpleasant surprises and check how different message configurations will affect your message text, number of characters and message parts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.preview_sms_message_with_http_info(sms_preview_request, async_req=True)
        >>> result = thread.get()

        :param sms_preview_request: (required)
        :type sms_preview_request: SmsPreviewRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsPreviewResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["sms_preview_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method preview_sms_message" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["sms_preview_request"]:
            _body_params = _params["sms_preview_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsPreviewResponse",
        }

        return self.api_client.call_api(
            "/sms/1/preview",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def reschedule_sms_messages(
        self, bulk_id: StrictStr, sms_bulk_request: SmsBulkRequest, **kwargs
    ) -> SmsBulkResponse:  # noqa: E501
        """Reschedule SMS messages  # noqa: E501

        Change the date and time of already scheduled messages. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reschedule_sms_messages(bulk_id, sms_bulk_request, async_req=True)
        >>> result = thread.get()

        :param bulk_id:  (required)
        :type bulk_id: str
        :param sms_bulk_request: (required)
        :type sms_bulk_request: SmsBulkRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsBulkResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.reschedule_sms_messages_with_http_info(
            bulk_id, sms_bulk_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def reschedule_sms_messages_with_http_info(
        self, bulk_id: StrictStr, sms_bulk_request: SmsBulkRequest, **kwargs
    ):  # noqa: E501
        """Reschedule SMS messages  # noqa: E501

        Change the date and time of already scheduled messages. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.reschedule_sms_messages_with_http_info(bulk_id, sms_bulk_request, async_req=True)
        >>> result = thread.get()

        :param bulk_id:  (required)
        :type bulk_id: str
        :param sms_bulk_request: (required)
        :type sms_bulk_request: SmsBulkRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsBulkResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["bulk_id", "sms_bulk_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reschedule_sms_messages" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("bulk_id") is not None:  # noqa: E501
            _query_params.append(("bulkId", _params["bulk_id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["sms_bulk_request"]:
            _body_params = _params["sms_bulk_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsBulkResponse",
        }

        return self.api_client.call_api(
            "/sms/1/bulks",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def send_binary_sms_message(
        self, sms_advanced_binary_request: SmsAdvancedBinaryRequest, **kwargs
    ) -> SmsResponse:  # noqa: E501
        """Send binary SMS message  # noqa: E501

        Send single or multiple binary messages to one or more destination address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_binary_sms_message(sms_advanced_binary_request, async_req=True)
        >>> result = thread.get()

        :param sms_advanced_binary_request: (required)
        :type sms_advanced_binary_request: SmsAdvancedBinaryRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.send_binary_sms_message_with_http_info(
            sms_advanced_binary_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def send_binary_sms_message_with_http_info(
        self, sms_advanced_binary_request: SmsAdvancedBinaryRequest, **kwargs
    ):  # noqa: E501
        """Send binary SMS message  # noqa: E501

        Send single or multiple binary messages to one or more destination address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_binary_sms_message_with_http_info(sms_advanced_binary_request, async_req=True)
        >>> result = thread.get()

        :param sms_advanced_binary_request: (required)
        :type sms_advanced_binary_request: SmsAdvancedBinaryRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["sms_advanced_binary_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_binary_sms_message" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["sms_advanced_binary_request"]:
            _body_params = _params["sms_advanced_binary_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsResponse",
        }

        return self.api_client.call_api(
            "/sms/2/binary/advanced",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def send_sms_message(
        self, sms_advanced_textual_request: SmsAdvancedTextualRequest, **kwargs
    ) -> SmsResponse:  # noqa: E501
        """Send SMS message  # noqa: E501

        99% of all use cases can be achieved by using this API method. Everything from sending a simple single message to a single destination, up to batch sending of personalized messages to the thousands of recipients with a single API request. Language, transliteration, scheduling and every advanced feature you can think of is supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_sms_message(sms_advanced_textual_request, async_req=True)
        >>> result = thread.get()

        :param sms_advanced_textual_request: (required)
        :type sms_advanced_textual_request: SmsAdvancedTextualRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.send_sms_message_with_http_info(
            sms_advanced_textual_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def send_sms_message_with_http_info(
        self, sms_advanced_textual_request: SmsAdvancedTextualRequest, **kwargs
    ):  # noqa: E501
        """Send SMS message  # noqa: E501

        99% of all use cases can be achieved by using this API method. Everything from sending a simple single message to a single destination, up to batch sending of personalized messages to the thousands of recipients with a single API request. Language, transliteration, scheduling and every advanced feature you can think of is supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.send_sms_message_with_http_info(sms_advanced_textual_request, async_req=True)
        >>> result = thread.get()

        :param sms_advanced_textual_request: (required)
        :type sms_advanced_textual_request: SmsAdvancedTextualRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["sms_advanced_textual_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method send_sms_message" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["sms_advanced_textual_request"]:
            _body_params = _params["sms_advanced_textual_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsResponse",
        }

        return self.api_client.call_api(
            "/sms/2/text/advanced",
            "POST",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )

    @validate_arguments
    def update_scheduled_sms_messages_status(
        self,
        bulk_id: StrictStr,
        sms_update_status_request: SmsUpdateStatusRequest,
        **kwargs
    ) -> SmsBulkStatusResponse:  # noqa: E501
        """Update scheduled SMS messages status  # noqa: E501

        Change the status or completely cancel sending of scheduled messages. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_scheduled_sms_messages_status(bulk_id, sms_update_status_request, async_req=True)
        >>> result = thread.get()

        :param bulk_id:  (required)
        :type bulk_id: str
        :param sms_update_status_request: (required)
        :type sms_update_status_request: SmsUpdateStatusRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SmsBulkStatusResponse
        """
        kwargs["_return_http_data_only"] = True
        return self.update_scheduled_sms_messages_status_with_http_info(
            bulk_id, sms_update_status_request, **kwargs
        )  # noqa: E501

    @validate_arguments
    def update_scheduled_sms_messages_status_with_http_info(
        self,
        bulk_id: StrictStr,
        sms_update_status_request: SmsUpdateStatusRequest,
        **kwargs
    ):  # noqa: E501
        """Update scheduled SMS messages status  # noqa: E501

        Change the status or completely cancel sending of scheduled messages. To schedule a message, use the `sendAt` field when [sending a message](https://www.infobip.com/docs/api/channels/sms/sms-messaging/outbound-sms/send-sms-message).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_scheduled_sms_messages_status_with_http_info(bulk_id, sms_update_status_request, async_req=True)
        >>> result = thread.get()

        :param bulk_id:  (required)
        :type bulk_id: str
        :param sms_update_status_request: (required)
        :type sms_update_status_request: SmsUpdateStatusRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SmsBulkStatusResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = ["bulk_id", "sms_update_status_request"]
        _all_params.extend(
            [
                "async_req",
                "_return_http_data_only",
                "_preload_content",
                "_request_timeout",
                "_request_auth",
                "_content_type",
                "_headers",
            ]
        )

        # validate the arguments
        for _key, _val in _params["kwargs"].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_scheduled_sms_messages_status" % _key
                )
            _params[_key] = _val
        del _params["kwargs"]

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get("bulk_id") is not None:  # noqa: E501
            _query_params.append(("bulkId", _params["bulk_id"]))

        # process the header parameters
        _header_params = dict(_params.get("_headers", {}))

        # process the form parameters
        _form_params = []
        _files = {}

        # process the body parameter
        _body_params = None
        if _params["sms_update_status_request"]:
            _body_params = _params["sms_update_status_request"]

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get(
            "_content_type",
            self.api_client.select_header_content_type(["application/json"]),
        )
        if _content_types_list:
            _header_params["Content-Type"] = _content_types_list

        # authentication setting
        _auth_settings = ["APIKeyHeader"]  # noqa: E501

        _response_types_map = {
            "200": "SmsBulkStatusResponse",
        }

        return self.api_client.call_api(
            "/sms/1/bulks/status",
            "PUT",
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get("async_req"),
            _return_http_data_only=_params.get("_return_http_data_only"),  # noqa: E501
            _preload_content=_params.get("_preload_content", True),
            _request_timeout=_params.get("_request_timeout"),
            collection_formats=_collection_formats,
            _request_auth=_params.get("_request_auth"),
        )
